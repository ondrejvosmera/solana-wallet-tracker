"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const datastream_filters_const_1 = require("./datastream-filters.const");
const filter = (type, operator, values) => ({
    type,
    operator,
    values,
});
describe("dataSteamFilters", () => {
    it("create TEXT type", () => {
        expect(datastream_filters_const_1.dataStreamFilters.text.equals("ABC")).toEqual(filter("TEXT", "==", ["ABC"]));
        expect(datastream_filters_const_1.dataStreamFilters.text.notEquals("ABC")).toEqual(filter("TEXT", "!=", ["ABC"]));
        expect(datastream_filters_const_1.dataStreamFilters.text.or(datastream_filters_const_1.dataStreamFilters.text.equals("ABC"), datastream_filters_const_1.dataStreamFilters.text.notEquals("CDE"))).toEqual({
            type: "OR",
            filters: [filter("TEXT", "==", ["ABC"]), filter("TEXT", "!=", ["CDE"])],
        });
    });
    it("create BOOLEAN type", () => {
        expect(datastream_filters_const_1.dataStreamFilters.boolean.equals(true)).toEqual(filter("BOOLEAN", "==", [true]));
        expect(datastream_filters_const_1.dataStreamFilters.boolean.equals(false)).toEqual(filter("BOOLEAN", "==", [false]));
    });
    it("create DATE type", () => {
        const date = new Date("2023-01-30T00:00:00z");
        expect(datastream_filters_const_1.dataStreamFilters.date.equals(date)).toEqual(filter("DATE", "==", [date.getTime() / 1000]) // Second resolution vs ms resolution
        );
        expect(datastream_filters_const_1.dataStreamFilters.date.notEquals(date)).toEqual(filter("DATE", "!=", [date.getTime() / 1000]) // Second resolution vs ms resolution
        );
        expect(datastream_filters_const_1.dataStreamFilters.date.or(datastream_filters_const_1.dataStreamFilters.date.equals(date), datastream_filters_const_1.dataStreamFilters.date.notEquals(date))).toEqual({
            type: "OR",
            filters: [
                filter("DATE", "==", [date.getTime() / 1000]),
                filter("DATE", "!=", [date.getTime() / 1000]),
            ],
        });
    });
    it("create NUMERIC type", () => {
        expect(datastream_filters_const_1.dataStreamFilters.numeric.equals(1)).toEqual(filter("NUMERIC", "==", [1]));
        expect(datastream_filters_const_1.dataStreamFilters.numeric.notEquals(1)).toEqual(filter("NUMERIC", "!=", [1]));
        expect(datastream_filters_const_1.dataStreamFilters.numeric.lessThan(1)).toEqual(filter("NUMERIC", "<", [1]));
        expect(datastream_filters_const_1.dataStreamFilters.numeric.lessThanEquals(1)).toEqual(filter("NUMERIC", "<=", [1]));
        expect(datastream_filters_const_1.dataStreamFilters.numeric.greaterThan(1)).toEqual(filter("NUMERIC", ">", [1]));
        expect(datastream_filters_const_1.dataStreamFilters.numeric.greaterThanEquals(1)).toEqual(filter("NUMERIC", ">=", [1]));
        expect(datastream_filters_const_1.dataStreamFilters.numeric.between(1, 10)).toEqual(filter("NUMERIC", "between", [1, 10]));
        expect(datastream_filters_const_1.dataStreamFilters.numeric.or(datastream_filters_const_1.dataStreamFilters.numeric.equals(1), datastream_filters_const_1.dataStreamFilters.numeric.notEquals(2))).toEqual({
            type: "OR",
            filters: [filter("NUMERIC", "==", [1]), filter("NUMERIC", "!=", [2])],
        });
    });
    it("create ENUM type", () => {
        expect(datastream_filters_const_1.dataStreamFilters.enum.equals("one")).toEqual(filter("ENUM", "==", ["one"]));
        expect(datastream_filters_const_1.dataStreamFilters.enum.notEquals("two")).toEqual(filter("ENUM", "!=", ["two"]));
        expect(datastream_filters_const_1.dataStreamFilters.enum.or(datastream_filters_const_1.dataStreamFilters.enum.equals("two"), datastream_filters_const_1.dataStreamFilters.enum.notEquals("one"))).toEqual({
            type: "OR",
            filters: [filter("ENUM", "==", ["two"]), filter("ENUM", "!=", ["one"])],
        });
    });
});
