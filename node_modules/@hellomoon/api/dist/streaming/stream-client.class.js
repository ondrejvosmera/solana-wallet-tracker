"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamClient = exports.isStreamError = void 0;
const websocket_1 = __importDefault(require("websocket"));
const uuid_1 = require("uuid");
const isBrowser = typeof window !== "undefined";
const isStreamError = (data) => data?.__type === "Error";
exports.isStreamError = isStreamError;
const _parse = (input) => {
    try {
        return JSON.parse(input);
    }
    catch {
        return input;
    }
};
class _WebStreamClient {
    apiKey;
    _client;
    constructor(apiKey) {
        this.apiKey = apiKey;
    }
    _send(method, params, requestId, retryCount = 0) {
        if (retryCount > 10) {
            return;
        }
        if (this._client && this._client.readyState === this._client.OPEN) {
            this._client?.send(JSON.stringify({
                id: requestId || (0, uuid_1.v4)(),
                jsonrpc: "2.0",
                method,
                params: params || {},
            }));
        }
        else {
            setTimeout(() => this._send(method, params, requestId, retryCount + 1), 300);
        }
    }
    async _authenticate(apiKey) {
        for (let i = 0; i < 30; i++) {
            if (this._client && this._client.readyState === this._client.OPEN) {
                this._client?.send(JSON.stringify({
                    id: (0, uuid_1.v4)(),
                    jsonrpc: "2.0",
                    method: "authenticate",
                    params: {
                        apiKey,
                    },
                }));
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        throw new Error("Could not authenticate");
    }
    subscribe(subscriptionId, requestId) {
        this._send("subscribe", { subscriptionId }, requestId);
        return () => {
            this._send("unsubscribe", { subscriptionId });
        };
    }
    connect(callback) {
        const self = this;
        return new Promise((resolve, reject) => {
            self._client = new websocket_1.default.w3cwebsocket("wss://kiki-stream.hellomoon.io");
            self._client.onmessage = (message) => {
                if (typeof message?.data !== "string")
                    return;
                const data = _parse(message.data);
                if (data?.result === "You have successfully subscribed") {
                    return;
                }
                callback(data);
            };
            self._client.onerror = reject;
            self._authenticate(this.apiKey).then(() => {
                return resolve(() => self._client?.close());
            });
        });
    }
    send(command, params, requestId) {
        this._send(command, params, requestId);
    }
    disconnect() {
        if (this._client && this._client.readyState === this._client.OPEN)
            this._client.close();
    }
}
class _StreamClient {
    apiKey;
    _connection;
    _client;
    constructor(apiKey) {
        this.apiKey = apiKey;
    }
    _send(method, params, requestId) {
        this._connection?.send(JSON.stringify({
            id: requestId || (0, uuid_1.v4)(),
            jsonrpc: "2.0",
            method,
            params: params || {},
        }));
    }
    subscribe(subscriptionId, requestId) {
        this._send("subscribe", { subscriptionId }, requestId);
        return () => {
            this._send("unsubscribe", { subscriptionId });
        };
    }
    connect(callback) {
        const self = this;
        return new Promise((resolve, reject) => {
            self._client = new websocket_1.default.client();
            self._client.connect("wss://kiki-stream.hellomoon.io", undefined, undefined, {
                Authorization: `Basic ${Buffer.from(`userid:${this.apiKey}`, "utf-8").toString("base64")}`,
            });
            self._client.on("connect", (connection) => {
                self._connection = connection;
                connection.on("message", (message) => {
                    if (!message || message.type !== "utf8")
                        return;
                    const data = _parse(message.utf8Data);
                    if (data?.result === "You have successfully subscribed") {
                        return;
                    }
                    callback(data);
                });
                connection.on("error", reject);
                return resolve(() => connection.close());
            });
        });
    }
    send(command, params, requestId) {
        this._send(command, params, requestId);
    }
    disconnect() {
        if (this._connection?.connected)
            this._connection.close();
    }
}
class StreamClient {
    _client;
    _callbackMap = {};
    constructor(apiKey) {
        this._client = isBrowser
            ? new _WebStreamClient(apiKey)
            : new _StreamClient(apiKey);
    }
    _addCallback(callback) {
        const id = (0, uuid_1.v4)();
        this._callbackMap[id] = {
            callback,
        };
        return id;
    }
    connect(fallback) {
        return this._client.connect((data) => {
            const output = "error" in data
                ? data.error
                : data.result;
            if (!data?.id)
                return fallback?.(output);
            const fullId = data.id;
            const idParts = typeof fullId === "string" ? fullId?.split(".") : [fullId];
            if (!idParts?.length)
                return fallback?.(output);
            const [id] = idParts;
            if (id in this._callbackMap === false)
                return fallback?.(output);
            this._callbackMap[id].callback(output);
        });
    }
    send(request) {
        let callback, failureCallback;
        const promise = new Promise((resolve, reject) => {
            callback = resolve;
            failureCallback = reject;
        });
        const id = this._addCallback((data) => {
            if ((0, exports.isStreamError)(data))
                failureCallback?.(data);
            else
                callback?.(data);
            delete this._callbackMap[id];
        });
        // This line splits on / removes the version at indexes 0 and 1 and joins them back with /
        this._client.send(`/${request.url.split("/").slice(2).join("/")}`, request.params, id);
        return promise;
    }
    subscribe(subscriptionId, callback, errorCallback) {
        const id = this._addCallback((data) => {
            if ((0, exports.isStreamError)(data))
                errorCallback?.(data);
            else
                callback(data);
        });
        const close = this._client.subscribe(subscriptionId, id);
        return () => {
            delete this._callbackMap[id];
            close();
        };
    }
    disconnect() {
        this._client.disconnect();
    }
}
exports.StreamClient = StreamClient;
