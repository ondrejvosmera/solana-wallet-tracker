import { BaseRequest } from "../BaseRequest.class";
import type { PaginatedResponse } from "../Response.interface";
export interface SolanaTxnsByUser {
    /**
     * Numeric identifier of a block describing the slot that the block was produced in
     */
    blockId: number;
    /**
     * Use this object when you get blocktime between two numbers
     * `optional field`
     */
    blockTime: {
        greaterThan: number;
        lessThan: number;
        operator: "between" | "null";
    };
    /**
     * First signature in a transaction, which can be used to track and verify the transaction status across
     * the complete ledger.
     *         It is a base-58 encoded string that is uniquely generated for each transaction.
     * `optional field`
     */
    transactionId: string;
    /**
     * public key of the account that received the reward (i.e, staking account)
     */
    userAccount: string;
    type: Array<"NFT_SALE" | "NFT_LISTING/DELISTING" | "TOKEN_SWAP" | "WITHDRAWAL/DEPOSITS" | "BORROWING/LENDING" | "NFT_MINT" | "TOKEN_TRANSFERS_BY_SOURCE_OWNER" | "TOKEN_TRANSFERS_BY_DESTINATION_OWNER"> | "NFT_SALE" | "NFT_LISTING/DELISTING" | "TOKEN_SWAP" | "WITHDRAWAL/DEPOSITS" | "BORROWING/LENDING" | "NFT_MINT" | "TOKEN_TRANSFERS_BY_SOURCE_OWNER" | "TOKEN_TRANSFERS_BY_DESTINATION_OWNER";
    parsedInfo: {
        market: Array<"SMB" | "ME_V1" | "ME_V2" | "YAWWW" | "Elixir" | "SolSea" | "OpenSea" | "Solanart" | "Hadeswap" | "CoralCube" | "Coral Cube" | "Exchange.Art"> | "SMB" | "ME_V1" | "ME_V2" | "YAWWW" | "Elixir" | "SolSea" | "OpenSea" | "Solanart" | "Hadeswap" | "CoralCube" | "Coral Cube" | "Exchange.Art";
        /**
     * The mint address of the NFT that was sold to the buyer by the seller.
     * `optional field`
     */
        mint: string;
        /**
     * PublicKey of the buyer of the NFT
     * `optional field`
     */
        buyer: string;
        /**
     * PublicKey of the seller of the NFT
     * `optional field`
     */
        seller: string;
        /**
     * The price of the NFT that was sold to the buyer.
     *       _price is denoted in Solana_
     */
        price: number;
        /**
     * > To find the correct helloMoonCollectionId, **[click here](https://www.hellomoon.io/id?search=collection)**
     * and search a collection name. This list is continuously updated.
     * `optional field`
     */
        collection_id: string;
    } | {
        /**
     * NFT listing price in lamports, will be zero if the nft is delisted **cancel_ask** - when converted the
     * price is a float with 6 decimal places of precision.
     */
        price: number;
        /**
     * Mint address of nft per the spl token program. Each NFT has a unique mint address within the collection.
     * `optional field`
     */
        mint: string;
        /**
     * The publickey of the wallet listing an NFT for sale or canceling their listing
     */
        seller: string;
        /**
     * Whether the listing is being created or canceled
     */
        isListing: boolean;
        market: Array<"MEv1" | "Solanart" | "SMB" | "MEv2" | "Yawww"> | "MEv1" | "Solanart" | "SMB" | "MEv2" | "Yawww";
    } | {
        /**
     * The aggregator name references a program that allows the user account to access liquidity from multiple
     * DEXs.
     *     The name is used to identify the liquidity provider used to execute the swap.
     */
        aggregatorName: string;
        /**
     * The program id references the DEX (decentralized exchange) address that is used to execute the swap with
     * their provided liquidity.
     *       > You can also visit https://www.hellomoon.io/id?search=dex to search for a DEX program using a
     * user interface.
     * `optional field`
     */
        programId: string;
        /**
     * The source mint references the token that is sent for the swap.
     *         For example, The user account swaps the source mint for the destination mint.
     * `optional field`
     */
        sourceMint: string;
        /**
     * The destination mint references the token that is received from the swap.
     *           For example, The user account swaps the source mint for the destination mint.
     * `optional field`
     */
        destinationMint: string;
        /**
     * The amount of the source mint sent for the swap.
     *         The amount is in the source mint's native unit, which is differentiated by it's decimal value.
     *         For example, the amount of 1,000,000 for the source mint of USDC would be 1 USDC since its decimal
     * value is 6.
     */
        sourceAmount: number;
        /**
     * The amount of destination mints received from the swap.
     *           The amount is in the source mint's native unit, which is differentiated by it's decimal value.
     *           For example, the amount of 1,000,000 for the source mint of USDC would be 1 USDC since its
     * decimal value is 6.
     */
        destinationAmount: number;
    } | {
        /**
     * The program id references the lending program that the user account is removing or adding tokens from
     * `optional field`
     */
        programId: string;
        actionType: Array<"removeLiquidity" | "addLiquidity"> | "removeLiquidity" | "addLiquidity";
        /**
     * Token mint A is the token address of the first token provided to the liquidity pool.
     *         The USD value of the deposit always needs to be split between the two tokens to ensure equal
     * value on each side.
     * `optional field`
     */
        tokenMintA: string;
        /**
     * Token mint B is the token address of the second token provided to the liquidity pool.
     *           The USD value of the deposit always needs to be split between the two tokens to ensure equal
     * value on each side.
     * `optional field`
     */
        tokenMintB: string;
        /**
     * The amount of (mint A) tokens that the user account is adding or removing from the liquidity pool.
     *         For example, the amount of 1,000,000 for the mint of USDC would be 1 USDC since its decimal value
     * is 6.
     */
        amountTokenA: number;
        /**
     * The amount of (mint B) tokens that the user account is adding or removing from the liquidity pool.
     *         For example, the amount of 1,000,000 for the mint of USDC would be 1 USDC since its decimal value
     * is 6.
     */
        amountTokenB: number;
    } | {
        /**
     * The programName references the lending protocol name
     *             that the user account is borrowing or repaying to.
     * `optional field`
     */
        programName: string;
        /**
     * The programId references the lending protocol
     *         that the user account is borrowing or repaying to.
     * `optional field`
     */
        programId: string;
        /**
     * Select the action types: **borrow** or **repay**.
     *     >If borrow, the endpoint returns the amount of tokens the user account borrowed from the program.
     *     >If repay, the endpoint returns the amount of tokens that are repaid to the user.
     */
        actionType: "borrow" | "repay";
        /**
     * Name of this instruction
     * `optional field`
     */
        instructionName: string;
        /**
     * The amount of tokens that the user account is repaying or borrowing.
     *         The amount is in the source mint's native unit, which is differentiated by it's decimal value.
     *         For example, the amount of 1,000,000 for the source mint of USDC would be 1 USDC since its decimal
     * value is 6.
     */
        amount: number;
        /**
     * The mint references the token that the user account is repaid or borrowing from the program.
     * `optional field`
     */
        mint: string;
    } | {
        /**
     * The program that minted this NFT.
     *     For example, the Candy Machine v2 program helps creators launch their NFT collections and brings
     * their metadata on the Solana blockchain.
     *
     *     **Choose a program address below to query by, each address is mapped to it's program name.**
     *     > cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ = Metaplex NFT Candy Machine v2
     *     > ArAA6CZC123yMJLUe4uisBEgvfuw2WEvex9iFmFCYiXv = nft_candy_machine
     *     > CMZYPASGWeTz7RNGHaRJfCq2XQ5pYK6nDvVQxzkH51zb = Nft Candy Machine
     *     > cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ = Metaplex NFT Candy Machine v1
     */
        mintProgram: "cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ" | "ArAA6CZC123yMJLUe4uisBEgvfuw2WEvex9iFmFCYiXv" | "CMZYPASGWeTz7RNGHaRJfCq2XQ5pYK6nDvVQxzkH51zb" | "cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ";
        /**
     * The user account that paid for the NFT to be minted on the mintProgram.
     *         The account will be the owner at the time of the mint, unless it was transferred to another account
     * afterwards.
     * `optional field`
     */
        payer: string;
        /**
     * The token account that created the NFT, before it was minted to the payer.
     *       The payer will pay this account an amount of tokens, NFTs or SOL in exchange for the NFT mint.
     */
        payee: string;
        /**
     * Amount paid in paymentMint's native tokens, unconverted for decimals.
     *       > If Amount = 1, it means the payer exchanged a claim token that is related to the creators of
     * the NFT collection for the mint. For example, 1 Trippin' Ape Tribe Mushroom Claim Token was used in exchange
     * for the mint of a MUSHROOM NFT.
     *
     *       > If Amount > 1, The amount is in the source mint's native unit, which is differentiated by it's
     * decimal value.
     *       For example, the amount of 1,000,000 for the source mint of USDC would be 1 USDC since its decimal
     * value is 6.
     */
        amount: number;
        /**
     * The mint address of the token that is received by the payee in exchange for the mint of the NFT.
     * `optional field`
     */
        paymentMint: string;
        /**
     * **The associated token account**. This program defined the mapping between the payer and the token accounts
     * that they own.
     *       A user may own many token accounts belonging to the same mint address.
     *       The associated token account introduces a way to deterministically map a user to a token account
     * then to the unique mint address.
     * `optional field`
     */
        wallet: string;
        /**
     * The mint address of the NFT that was minted and received by the payer.
     * `optional field`
     */
        mint: string;
        /**
     * > To find the correct helloMoonCollectionId, **[click here](https://www.hellomoon.io/id?search=collection)**
     * and search a collection name. This list is continuously updated.
     * `optional field`
     */
        collectionId: string;
    } | {
        /**
     * source owner is the per owner of the source (token account), each token account will refer to a distinct
     * token mint
     * `optional field`
     */
        sourceOwner: string;
        /**
     * Token account of a mint owned by the token program (Spl Token Program). It holds information about the
     * tokens owned by a public key
     * `optional field`
     */
        source: string;
        /**
     * destination owner is the per owner of the destination (token account), each token account will refer
     * to a distinct token mint
     * `optional field`
     */
        destinationOwner: string;
        /**
     * Token account of a mint owned by the token program (Spl Token Program). It holds information about the
     * tokens owned by a public key
     * `optional field`
     */
        destination: string;
        type: Array<"closeAccount" | "createAccount" | "createAccountWithSeed" | "transferChecked" | "transfer"> | "closeAccount" | "createAccount" | "createAccountWithSeed" | "transferChecked" | "transfer";
        amount: {
            value: number;
            operator: "=" | "!=" | "<" | "<=" | ">" | ">=";
        };
        /**
     * Mint address per the SPL token program.
     *       > You can also visit https://www.hellomoon.io/id?search=token to search for mints using a user
     * interface.
     */
        mint: string;
        /**
     * new balance (in lamports) of destination token account
     */
        newDestinationBalance: number;
        /**
     * new balance (in lamports) of source token account
     */
        newSourceBalance: number;
        /**
     * old balance (in lamports) of destination token account
     */
        oldDestinationBalance: number;
        /**
     * old balance (in lamports) of source token account
     */
        oldSourceBalance: number;
    };
}
export interface SolanaTxnsByUserRequestArgs {
    /**
     * public key of the account that received the reward (i.e, staking account)
     */
    userAccount?: string;
    type?: Array<"NFT_SALE" | "NFT_LISTING/DELISTING" | "TOKEN_SWAP" | "WITHDRAWAL/DEPOSITS" | "BORROWING/LENDING" | "NFT_MINT" | "TOKEN_TRANSFERS_BY_SOURCE_OWNER" | "TOKEN_TRANSFERS_BY_DESTINATION_OWNER"> | "NFT_SALE" | "NFT_LISTING/DELISTING" | "TOKEN_SWAP" | "WITHDRAWAL/DEPOSITS" | "BORROWING/LENDING" | "NFT_MINT" | "TOKEN_TRANSFERS_BY_SOURCE_OWNER" | "TOKEN_TRANSFERS_BY_DESTINATION_OWNER";
    /**
     * Use this object when you get blocktime between two numbers
     * `optional field`
     */
    blockTime?: {
        greaterThan: number;
        lessThan: number;
        operator: "between" | "null";
    };
    /**
     * First signature in a transaction, which can be used to track and verify the transaction status across
     * the complete ledger.
     *         It is a base-58 encoded string that is uniquely generated for each transaction.
     * `optional field`
     */
    transactionId?: string;
    /**
     * The number of results to return per page
     * `optional field`
     */
    limit?: number;
    /**
     * The page number to return
     * `optional field`
     */
    page?: number;
    /**
     * The pagination token to use to keep your position in the results
     * `optional field`
     */
    paginationToken?: string;
}
export declare class SolanaTxnsByUserRequest extends BaseRequest<SolanaTxnsByUserRequestArgs, PaginatedResponse<SolanaTxnsByUser>> {
    readonly body: SolanaTxnsByUserRequestArgs;
    readonly method = "POST";
    readonly url = "/v0/solana/txns-by-user";
    constructor(body?: SolanaTxnsByUserRequestArgs);
}
