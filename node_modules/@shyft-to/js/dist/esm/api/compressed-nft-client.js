import { restApiCall, CaseConverter } from '../utils';
import { isNumber } from 'lodash';
export class CompressedNftClient {
    constructor(config) {
        this.config = config;
        this.caseConverter = new CaseConverter();
    }
    async createMerkleTree(input) {
        var _a;
        try {
            if (!CompressedNftClient.isValidDepthSizePair(input.maxDepthSizePair)) {
                throw new Error('Invalid depth size pair');
            }
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                wallet_address: input.walletAddress,
                max_depth_size_pair: this.caseConverter.convertToSnakeCaseObject(input.maxDepthSizePair),
                canopy_depth: input.canopyDepth,
            };
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                reqBody['fee_payer'] = input.feePayer;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/compressed/create_tree',
                data: reqBody,
            });
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async mint(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                creator_wallet: input.creatorWallet,
                merkle_tree: input.merkleTree,
                metadata_uri: input.metadataUri,
            };
            if (input === null || input === void 0 ? void 0 : input.isDelegateAuthority) {
                reqBody['is_delegate_authority'] = input.isDelegateAuthority;
            }
            if (input === null || input === void 0 ? void 0 : input.collectionAddress) {
                reqBody['collection_address'] = input.collectionAddress;
            }
            if (input === null || input === void 0 ? void 0 : input.maxSupply) {
                reqBody['max_supply'] = input.maxSupply;
            }
            if (input === null || input === void 0 ? void 0 : input.primarySaleHappend) {
                reqBody['primary_sale_happend'] = input.primarySaleHappend;
            }
            if (input === null || input === void 0 ? void 0 : input.isMutable) {
                reqBody['is_mutable'] = input.isMutable;
            }
            if (input === null || input === void 0 ? void 0 : input.receiver) {
                reqBody['receiver'] = input.receiver;
            }
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                reqBody['fee_payer'] = input.feePayer;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/compressed/mint',
                data: reqBody,
            });
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async transfer(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                nft_address: input.mint,
                sender: input.fromAddress,
                receiver: input.toAddress,
            };
            if (input.feePayer) {
                reqBody['fee_payer'] = input.feePayer;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/compressed/transfer',
                data: reqBody,
            });
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async transferMany(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                nft_addresses: input.mints,
                from_address: input.fromAddress,
                to_address: input.toAddress,
            };
            if (input.feePayer) {
                reqBody['fee_payer'] = input.feePayer;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/compressed/transfer_many',
                data: reqBody,
            });
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async burn(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                wallet_address: input.walletAddress,
                nft_address: input.mint,
            };
            const data = await restApiCall(this.config.apiKey, {
                method: 'delete',
                url: 'nft/compressed/burn',
                data: reqBody,
            });
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async burnMany(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                nft_addresses: input.mints,
                wallet_address: input.walletAddress,
            };
            const data = await restApiCall(this.config.apiKey, {
                method: 'delete',
                url: 'nft/compressed/burn_many',
                data: reqBody,
            });
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async read(input) {
        var _a;
        try {
            const params = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                nft_address: input.mint,
            };
            const data = await restApiCall(this.config.apiKey, {
                method: 'get',
                url: 'nft/compressed/read',
                params,
            });
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async readAll(input) {
        var _a;
        try {
            const params = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                wallet_address: input.walletAddress,
            };
            if (input.collection) {
                params['collection'] = input.collection;
            }
            if (input.refresh) {
                params['refresh'] = input.refresh;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'get',
                url: 'nft/compressed/read_all',
                params,
            });
            const response = data.result.nfts;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async readAllV2(input) {
        var _a;
        try {
            const params = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                wallet_address: input.walletAddress,
            };
            if (input.collection) {
                params['collection'] = input.collection;
            }
            if (input.refresh) {
                params['refresh'] = input.refresh;
            }
            if (isNumber(input === null || input === void 0 ? void 0 : input.page)) {
                if (input.page < 1) {
                    throw new Error('should not be less than 1: size');
                }
                params['page'] = input.page;
            }
            if (isNumber(input === null || input === void 0 ? void 0 : input.size)) {
                if (input.size > 50 || input.size < 1) {
                    throw new Error('allowed between 1 to 50: size');
                }
                params['size'] = input.size;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'get',
                url: 'nft/compressed/read_all',
                params,
            }, 'v2');
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    async readSelected(input) {
        var _a;
        try {
            if (input.mints.length > 10 || input.mints.length < 1) {
                throw new Error('allowed between 1 to 10: mints');
            }
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                nft_addresses: input.mints,
            };
            if (input.refresh) {
                reqBody['refresh'] = input.refresh;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/compressed/read_selected',
                data: reqBody,
            });
            const response = data.result;
            return response;
        }
        catch (error) {
            throw error;
        }
    }
    static isValidDepthSizePair(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        const validPairs = [
            { maxDepth: 3, maxBufferSize: 8 },
            { maxDepth: 5, maxBufferSize: 8 },
            { maxDepth: 14, maxBufferSize: 64 },
            { maxDepth: 14, maxBufferSize: 256 },
            { maxDepth: 14, maxBufferSize: 1024 },
            { maxDepth: 14, maxBufferSize: 2048 },
            { maxDepth: 15, maxBufferSize: 64 },
            { maxDepth: 16, maxBufferSize: 64 },
            { maxDepth: 17, maxBufferSize: 64 },
            { maxDepth: 18, maxBufferSize: 64 },
            { maxDepth: 19, maxBufferSize: 64 },
            { maxDepth: 20, maxBufferSize: 64 },
            { maxDepth: 20, maxBufferSize: 256 },
            { maxDepth: 20, maxBufferSize: 1024 },
            { maxDepth: 20, maxBufferSize: 2048 },
            { maxDepth: 24, maxBufferSize: 64 },
            { maxDepth: 24, maxBufferSize: 256 },
            { maxDepth: 24, maxBufferSize: 512 },
            { maxDepth: 24, maxBufferSize: 1024 },
            { maxDepth: 24, maxBufferSize: 2048 },
            { maxDepth: 26, maxBufferSize: 512 },
            { maxDepth: 26, maxBufferSize: 1024 },
            { maxDepth: 26, maxBufferSize: 2048 },
            { maxDepth: 30, maxBufferSize: 512 },
            { maxDepth: 30, maxBufferSize: 1024 },
            { maxDepth: 30, maxBufferSize: 2048 },
        ];
        return validPairs.some((pair) => {
            return (pair.maxDepth === obj.maxDepth &&
                pair.maxBufferSize === obj.maxBufferSize);
        });
    }
}
//# sourceMappingURL=compressed-nft-client.js.map