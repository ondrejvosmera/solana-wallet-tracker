import FormData from 'form-data';
import { restApiCall } from '../utils';
import { CollectionClient } from './collection-client';
import { CompressedNftClient } from './compressed-nft-client';
import { isNumber } from 'lodash';
export class NftClient {
    constructor(config) {
        this.config = config;
        this.collection = new CollectionClient(this.config);
        this.compressed = new CompressedNftClient(this.config);
    }
    async getNftByMint(input) {
        var _a;
        try {
            const params = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                token_address: input.mint,
            };
            if (input.refresh) {
                params['refresh'] = input.refresh;
            }
            if (input.tokenRecord) {
                params['token_record'] = input.tokenRecord;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'get',
                url: 'nft/read',
                params,
            });
            const nft = data.result;
            return nft;
        }
        catch (error) {
            throw error;
        }
    }
    async getNftsByMintAddresses(input) {
        var _a;
        try {
            if (input.mints.length === 0) {
                throw new Error('At least one mint address is required');
            }
            if (input.mints.length > 10) {
                throw new Error('Allowed between 1 to 10: mints');
            }
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                token_addresses: input.mints,
            };
            if (input.refresh) {
                reqBody['refresh'] = input.refresh;
            }
            if (input.tokenRecord) {
                reqBody['token_record'] = input.tokenRecord;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/read_selected',
                data: reqBody,
            });
            const nfts = data.result;
            return nfts;
        }
        catch (error) {
            throw error;
        }
    }
    async getNftByOwner(input) {
        var _a;
        try {
            const params = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                address: input.owner,
            };
            const data = await restApiCall(this.config.apiKey, {
                method: 'get',
                url: 'nft/read_all',
                params,
            });
            const nft = data.result;
            return nft;
        }
        catch (error) {
            throw error;
        }
    }
    async getNftsByOwnerV2(input) {
        var _a;
        try {
            const params = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                address: input.owner,
            };
            if (input.updateAuthority) {
                params['update_authority'] = input.updateAuthority;
            }
            if (input.refresh) {
                params['refresh'] = input.refresh;
            }
            if (isNumber(input === null || input === void 0 ? void 0 : input.page)) {
                if (input.page < 1) {
                    throw new Error('should not be less than 1: size');
                }
                params['page'] = input.page;
            }
            if (isNumber(input === null || input === void 0 ? void 0 : input.size)) {
                if (input.size > 50 || input.size < 1) {
                    throw new Error('allowed between 1 to 50: size');
                }
                params['size'] = input.size;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'get',
                url: 'nft/read_all',
                params,
            }, 'v2');
            const nft = data.result;
            return nft;
        }
        catch (error) {
            throw error;
        }
    }
    async getOwners(input) {
        var _a;
        try {
            if (input.mints.length < 1 || input.mints.length > 10) {
                throw new Error('allowed between 1 to 10: mints');
            }
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                nft_addresses: input.mints,
            };
            const response = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/get_owners',
                data: reqBody,
            });
            const nftMintsAndOwners = response.result;
            return nftMintsAndOwners;
        }
        catch (error) {
            throw error;
        }
    }
    async createFromMetadata(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                metadata_uri: input.metadataUri,
                receiver: input.receiver,
            };
            if (input === null || input === void 0 ? void 0 : input.maxSupply) {
                reqBody['max_supply'] = input.maxSupply;
            }
            if (input === null || input === void 0 ? void 0 : input.collectionAddress) {
                reqBody['collection_address'] = input.collectionAddress;
            }
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                reqBody['fee_payer'] = input.feePayer;
            }
            if (input === null || input === void 0 ? void 0 : input.serviceCharge) {
                reqBody['service_charge'] = input.serviceCharge;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/create_from_metadata',
                data: reqBody,
            });
            const result = data.result;
            return result;
        }
        catch (error) {
            throw error;
        }
    }
    async burn(input) {
        var _a, _b;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                wallet: input.wallet,
                token_address: input.mint,
            };
            if (input === null || input === void 0 ? void 0 : input.close) {
                reqBody['close'] = input.close;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'delete',
                url: 'nft/burn_detach',
                data: reqBody,
            });
            const encodedTransaction = (_b = data.result) === null || _b === void 0 ? void 0 : _b.encoded_transaction;
            return encodedTransaction;
        }
        catch (error) {
            throw error;
        }
    }
    async burnMany(input) {
        var _a, _b;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                wallet: input.wallet,
                nft_addresses: input.mints,
            };
            if (input === null || input === void 0 ? void 0 : input.close) {
                reqBody['close_accounts'] = input.close;
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'delete',
                url: 'nft/burn_many',
                data: reqBody,
            });
            const encodedTransactions = (_b = data.result) === null || _b === void 0 ? void 0 : _b.encoded_transactions;
            return encodedTransactions;
        }
        catch (error) {
            throw error;
        }
    }
    async transfer(input) {
        var _a, _b, _c;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                token_address: input.mint,
                from_address: input.fromAddress,
                to_address: input.toAddress,
                transfer_authority: (_b = input === null || input === void 0 ? void 0 : input.transferAuthority) !== null && _b !== void 0 ? _b : false,
            };
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/transfer_detach',
                data: reqBody,
            });
            const encodedTransaction = (_c = data.result) === null || _c === void 0 ? void 0 : _c.encoded_transaction;
            return encodedTransaction;
        }
        catch (error) {
            throw error;
        }
    }
    async transferMultiple(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                token_addresses: input.mints,
                from_address: input.fromAddress,
                to_address: input.toAddress,
            };
            const data = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/transfer_many',
                data: reqBody,
            });
            const encodedTransactions = data.result.encoded_transactions;
            return encodedTransactions;
        }
        catch (error) {
            throw error;
        }
    }
    async createV2(input) {
        var _a;
        try {
            let data = new FormData();
            data.append('network', (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network);
            data.append('creator_wallet', input.creatorWallet);
            data.append('name', input.name);
            data.append('symbol', input.symbol);
            if (input === null || input === void 0 ? void 0 : input.description) {
                data.append('description', input.description);
            }
            if (input === null || input === void 0 ? void 0 : input.attributes) {
                data.append('attributes', JSON.stringify(input.attributes));
            }
            if (input === null || input === void 0 ? void 0 : input.externalUrl) {
                data.append('external_url', input.externalUrl);
            }
            if (input === null || input === void 0 ? void 0 : input.maxSupply) {
                data.append('max_supply', input.maxSupply.toString());
            }
            if (input === null || input === void 0 ? void 0 : input.royalty) {
                data.append('royalty', input.royalty.toString());
            }
            if (input === null || input === void 0 ? void 0 : input.collectionAddress) {
                data.append('collection_address', input.collectionAddress);
            }
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                data.append('fee_payer', input.feePayer);
            }
            data.append('image', input.image);
            if (input === null || input === void 0 ? void 0 : input.data) {
                data.append('data', input.data);
            }
            const response = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/create',
                maxBodyLength: Infinity,
                data,
            }, 'v2');
            const result = response.result;
            return result;
        }
        catch (error) {
            throw error;
        }
    }
    async updateV2(input) {
        var _a;
        try {
            let data = new FormData();
            data.append('network', (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network);
            data.append('token_address', input.mint);
            data.append('update_authority_address', input.updateAuthority);
            if (input === null || input === void 0 ? void 0 : input.name) {
                if (input.name.length > 32) {
                    throw new Error('Max length allowed 32: name');
                }
                data.append('name', input.name);
            }
            if (input === null || input === void 0 ? void 0 : input.symbol) {
                if (input.symbol.length > 10) {
                    throw new Error('Max length allowed 10: symbol');
                }
                data.append('symbol', input.symbol);
            }
            if (input === null || input === void 0 ? void 0 : input.description) {
                data.append('description', input.description);
            }
            if (input === null || input === void 0 ? void 0 : input.attributes) {
                data.append('attributes', JSON.stringify(input.attributes));
            }
            if (input === null || input === void 0 ? void 0 : input.royalty) {
                data.append('royalty', input.royalty.toString());
            }
            if (input === null || input === void 0 ? void 0 : input.image) {
                data.append('image', input.image);
            }
            if (input === null || input === void 0 ? void 0 : input.data) {
                data.append('data', input.data);
            }
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                data.append('fee_payer', input.feePayer);
            }
            if (input === null || input === void 0 ? void 0 : input.serviceCharge) {
                data.append('service_charge', input.serviceCharge);
            }
            const response = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'nft/update',
                maxBodyLength: Infinity,
                data,
            }, 'v2');
            const result = {
                encoded_transaction: response.result,
                mint: input.mint,
            };
            return result;
        }
        catch (error) {
            throw error;
        }
    }
}
//# sourceMappingURL=nft-client.js.map