import { ShyftConfig } from '../utils';
import { CNftBurnManyResp, CNftBurnResponse, CNftMintResponse, CNftTransferManyResp, CNftTransferResponse, CreateMerkleTreeResponse, Network, Nft, PaginatedNfts, ValidDepthSizePair } from '../types';
export declare class CompressedNftClient {
    private readonly config;
    private caseConverter;
    constructor(config: ShyftConfig);
    createMerkleTree(input: {
        network?: Network;
        walletAddress: string;
        maxDepthSizePair: ValidDepthSizePair;
        canopyDepth: number;
        feePayer?: string;
    }): Promise<CreateMerkleTreeResponse>;
    mint(input: {
        network?: Network;
        creatorWallet: string;
        merkleTree: string;
        metadataUri: string;
        isDelegateAuthority?: boolean;
        collectionAddress?: string;
        maxSupply?: number;
        primarySaleHappend?: boolean;
        isMutable?: boolean;
        receiver?: string;
        feePayer?: string;
    }): Promise<CNftMintResponse>;
    transfer(input: {
        network?: Network;
        mint: string;
        fromAddress: string;
        toAddress: string;
        feePayer?: string;
    }): Promise<CNftTransferResponse>;
    transferMany(input: {
        network?: Network;
        mints: string[];
        fromAddress: string;
        toAddress: string;
        feePayer?: string;
    }): Promise<CNftTransferManyResp>;
    burn(input: {
        network?: Network;
        walletAddress: string;
        mint: string;
    }): Promise<CNftBurnResponse>;
    burnMany(input: {
        network?: Network;
        mints: string[];
        walletAddress: string;
    }): Promise<CNftBurnManyResp>;
    read(input: {
        network?: Network;
        mint: string;
    }): Promise<Nft>;
    readAll(input: {
        network?: Network;
        walletAddress: string;
        collection?: string;
        refresh?: boolean;
    }): Promise<Nft[]>;
    readAllV2(input: {
        network?: Network;
        walletAddress: string;
        collection?: string;
        refresh?: boolean;
        page?: number;
        size?: number;
    }): Promise<PaginatedNfts>;
    readSelected(input: {
        network?: Network;
        mints: string[];
        refresh?: boolean;
    }): Promise<Nft[]>;
    static isValidDepthSizePair(obj: any): obj is ValidDepthSizePair;
}
