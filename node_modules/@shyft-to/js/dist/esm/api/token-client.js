import FormData from 'form-data';
import { restApiCall } from '../utils';
import { Network, } from '../types';
export class TokenClient {
    constructor(config) {
        this.config = config;
    }
    async getInfo(input) {
        var _a;
        try {
            const params = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                token_address: input.tokenAddress,
            };
            const data = await restApiCall(this.config.apiKey, {
                method: 'get',
                url: 'token/get_info',
                params,
            });
            const tokenInfo = data.result;
            return tokenInfo;
        }
        catch (error) {
            throw error;
        }
    }
    async getOwners(input) {
        var _a, _b, _c;
        try {
            const params = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                token_address: input.tokenAddress,
                limit: (_b = input === null || input === void 0 ? void 0 : input.limit) !== null && _b !== void 0 ? _b : 10,
                offset: (_c = input === null || input === void 0 ? void 0 : input.offset) !== null && _c !== void 0 ? _c : 0,
            };
            if (params.network !== Network.Mainnet) {
                throw new Error('This operation only available on mainnet-beta');
            }
            const data = await restApiCall(this.config.apiKey, {
                method: 'get',
                url: 'token/get_owners',
                params,
            });
            const tokenOwners = data.result;
            return tokenOwners;
        }
        catch (error) {
            throw error;
        }
    }
    async create(input) {
        var _a;
        try {
            let data = new FormData();
            data.append('network', (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network);
            data.append('wallet', input.creatorWallet);
            if (input.name.length > 32) {
                throw new Error('Max length allowed 32: name');
            }
            data.append('name', input.name);
            if (input.symbol.length > 10) {
                throw new Error('Max length allowed 10: symbol');
            }
            data.append('symbol', input.symbol);
            data.append('file', input.image);
            if (input.decimals < 0 || input.decimals > 9) {
                throw new Error('0 to 9 allowed: decimals');
            }
            if (input === null || input === void 0 ? void 0 : input.description) {
                data.append('description', input.description);
            }
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                data.append('fee_payer', input.feePayer);
            }
            const response = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'token/create_detach',
                maxBodyLength: Infinity,
                data,
            });
            return response.result;
        }
        catch (error) {
            throw error;
        }
    }
    async mint(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                mint_authority: input.mintAuthority,
                receiver: input.receiver,
                token_address: input.tokenAddress,
                amount: input.amount,
            };
            if (input === null || input === void 0 ? void 0 : input.message) {
                reqBody['message'] = input.message;
            }
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                reqBody['fee_payer'] = input.feePayer;
            }
            const response = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'token/mint_detach',
                data: reqBody,
            });
            return response.result;
        }
        catch (error) {
            throw error;
        }
    }
    async burn(input) {
        var _a;
        try {
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                wallet: input.wallet,
                token_address: input.tokenAddress,
                amount: input.amount,
            };
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                reqBody['fee_payer'] = input.feePayer;
            }
            const response = await restApiCall(this.config.apiKey, {
                method: 'delete',
                url: 'token/burn_detach',
                data: reqBody,
            });
            return response.result;
        }
        catch (error) {
            throw error;
        }
    }
    async transfer(input) {
        var _a;
        try {
            if (input.fromAddress === input.toAddress) {
                throw new Error('fromAddress and toAddress must not be the same');
            }
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                from_address: input.fromAddress,
                to_address: input.toAddress,
                token_address: input.tokenAddress,
                amount: input.amount,
            };
            if (input === null || input === void 0 ? void 0 : input.feePayer) {
                reqBody['fee_payer'] = input.feePayer;
            }
            const response = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'token/transfer_detach',
                data: reqBody,
            });
            return response.result;
        }
        catch (error) {
            throw error;
        }
    }
    async airdrop(input) {
        var _a;
        try {
            const transferTo = input.transferTo.map((x) => {
                if (x.toAddress === input.fromAddress) {
                    throw new Error('fromAddress and toAddress must not be the same');
                }
                return { to_address: x.toAddress, amount: x.amount };
            });
            const reqBody = {
                network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                from_address: input.fromAddress,
                transfer_info: transferTo,
                token_address: input.tokenAddress,
            };
            const response = await restApiCall(this.config.apiKey, {
                method: 'post',
                url: 'token/airdrop',
                data: reqBody,
            });
            return response.result;
        }
        catch (error) {
            throw error;
        }
    }
}
//# sourceMappingURL=token-client.js.map