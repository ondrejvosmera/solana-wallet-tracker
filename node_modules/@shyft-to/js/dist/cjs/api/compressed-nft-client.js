"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompressedNftClient = void 0;
const utils_1 = require("../utils");
const lodash_1 = require("lodash");
class CompressedNftClient {
    constructor(config) {
        this.config = config;
        this.caseConverter = new utils_1.CaseConverter();
    }
    createMerkleTree(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!CompressedNftClient.isValidDepthSizePair(input.maxDepthSizePair)) {
                    throw new Error('Invalid depth size pair');
                }
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    wallet_address: input.walletAddress,
                    max_depth_size_pair: this.caseConverter.convertToSnakeCaseObject(input.maxDepthSizePair),
                    canopy_depth: input.canopyDepth,
                };
                if (input === null || input === void 0 ? void 0 : input.feePayer) {
                    reqBody['fee_payer'] = input.feePayer;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/compressed/create_tree',
                    data: reqBody,
                });
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    mint(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    creator_wallet: input.creatorWallet,
                    merkle_tree: input.merkleTree,
                    metadata_uri: input.metadataUri,
                };
                if (input === null || input === void 0 ? void 0 : input.isDelegateAuthority) {
                    reqBody['is_delegate_authority'] = input.isDelegateAuthority;
                }
                if (input === null || input === void 0 ? void 0 : input.collectionAddress) {
                    reqBody['collection_address'] = input.collectionAddress;
                }
                if (input === null || input === void 0 ? void 0 : input.maxSupply) {
                    reqBody['max_supply'] = input.maxSupply;
                }
                if (input === null || input === void 0 ? void 0 : input.primarySaleHappend) {
                    reqBody['primary_sale_happend'] = input.primarySaleHappend;
                }
                if (input === null || input === void 0 ? void 0 : input.isMutable) {
                    reqBody['is_mutable'] = input.isMutable;
                }
                if (input === null || input === void 0 ? void 0 : input.receiver) {
                    reqBody['receiver'] = input.receiver;
                }
                if (input === null || input === void 0 ? void 0 : input.feePayer) {
                    reqBody['fee_payer'] = input.feePayer;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/compressed/mint',
                    data: reqBody,
                });
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    transfer(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    nft_address: input.mint,
                    sender: input.fromAddress,
                    receiver: input.toAddress,
                };
                if (input.feePayer) {
                    reqBody['fee_payer'] = input.feePayer;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/compressed/transfer',
                    data: reqBody,
                });
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    transferMany(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    nft_addresses: input.mints,
                    from_address: input.fromAddress,
                    to_address: input.toAddress,
                };
                if (input.feePayer) {
                    reqBody['fee_payer'] = input.feePayer;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/compressed/transfer_many',
                    data: reqBody,
                });
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    burn(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    wallet_address: input.walletAddress,
                    nft_address: input.mint,
                };
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'delete',
                    url: 'nft/compressed/burn',
                    data: reqBody,
                });
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    burnMany(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    nft_addresses: input.mints,
                    wallet_address: input.walletAddress,
                };
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'delete',
                    url: 'nft/compressed/burn_many',
                    data: reqBody,
                });
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    read(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const params = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    nft_address: input.mint,
                };
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'get',
                    url: 'nft/compressed/read',
                    params,
                });
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    readAll(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const params = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    wallet_address: input.walletAddress,
                };
                if (input.collection) {
                    params['collection'] = input.collection;
                }
                if (input.refresh) {
                    params['refresh'] = input.refresh;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'get',
                    url: 'nft/compressed/read_all',
                    params,
                });
                const response = data.result.nfts;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    readAllV2(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const params = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    wallet_address: input.walletAddress,
                };
                if (input.collection) {
                    params['collection'] = input.collection;
                }
                if (input.refresh) {
                    params['refresh'] = input.refresh;
                }
                if ((0, lodash_1.isNumber)(input === null || input === void 0 ? void 0 : input.page)) {
                    if (input.page < 1) {
                        throw new Error('should not be less than 1: size');
                    }
                    params['page'] = input.page;
                }
                if ((0, lodash_1.isNumber)(input === null || input === void 0 ? void 0 : input.size)) {
                    if (input.size > 50 || input.size < 1) {
                        throw new Error('allowed between 1 to 50: size');
                    }
                    params['size'] = input.size;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'get',
                    url: 'nft/compressed/read_all',
                    params,
                }, 'v2');
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    readSelected(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (input.mints.length > 10 || input.mints.length < 1) {
                    throw new Error('allowed between 1 to 10: mints');
                }
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    nft_addresses: input.mints,
                };
                if (input.refresh) {
                    reqBody['refresh'] = input.refresh;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/compressed/read_selected',
                    data: reqBody,
                });
                const response = data.result;
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    static isValidDepthSizePair(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        const validPairs = [
            { maxDepth: 3, maxBufferSize: 8 },
            { maxDepth: 5, maxBufferSize: 8 },
            { maxDepth: 14, maxBufferSize: 64 },
            { maxDepth: 14, maxBufferSize: 256 },
            { maxDepth: 14, maxBufferSize: 1024 },
            { maxDepth: 14, maxBufferSize: 2048 },
            { maxDepth: 15, maxBufferSize: 64 },
            { maxDepth: 16, maxBufferSize: 64 },
            { maxDepth: 17, maxBufferSize: 64 },
            { maxDepth: 18, maxBufferSize: 64 },
            { maxDepth: 19, maxBufferSize: 64 },
            { maxDepth: 20, maxBufferSize: 64 },
            { maxDepth: 20, maxBufferSize: 256 },
            { maxDepth: 20, maxBufferSize: 1024 },
            { maxDepth: 20, maxBufferSize: 2048 },
            { maxDepth: 24, maxBufferSize: 64 },
            { maxDepth: 24, maxBufferSize: 256 },
            { maxDepth: 24, maxBufferSize: 512 },
            { maxDepth: 24, maxBufferSize: 1024 },
            { maxDepth: 24, maxBufferSize: 2048 },
            { maxDepth: 26, maxBufferSize: 512 },
            { maxDepth: 26, maxBufferSize: 1024 },
            { maxDepth: 26, maxBufferSize: 2048 },
            { maxDepth: 30, maxBufferSize: 512 },
            { maxDepth: 30, maxBufferSize: 1024 },
            { maxDepth: 30, maxBufferSize: 2048 },
        ];
        return validPairs.some((pair) => {
            return (pair.maxDepth === obj.maxDepth &&
                pair.maxBufferSize === obj.maxBufferSize);
        });
    }
}
exports.CompressedNftClient = CompressedNftClient;
//# sourceMappingURL=compressed-nft-client.js.map