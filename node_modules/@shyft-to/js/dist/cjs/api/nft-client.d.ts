import { ShyftConfig } from '../utils';
import { Attribute, Network, Nft, NftMintAndOwner, PaginatedNfts, ServiceCharge } from '../types';
import { CollectionClient } from './collection-client';
import { CompressedNftClient } from './compressed-nft-client';
export declare class NftClient {
    private readonly config;
    readonly collection: CollectionClient;
    readonly compressed: CompressedNftClient;
    constructor(config: ShyftConfig);
    getNftByMint(input: {
        network?: Network;
        mint: string;
        refresh?: boolean;
        tokenRecord?: boolean;
    }): Promise<Nft>;
    getNftsByMintAddresses(input: {
        network?: Network;
        mints: string[];
        refresh?: boolean;
        tokenRecord?: boolean;
    }): Promise<Nft[]>;
    getNftByOwner(input: {
        network?: Network;
        owner: string;
    }): Promise<Nft[]>;
    getNftsByOwnerV2(input: {
        network?: Network;
        owner: string;
        updateAuthority?: string;
        refresh?: boolean;
        page?: number;
        size?: number;
    }): Promise<PaginatedNfts>;
    getOwners(input: {
        network?: Network;
        mints: string[];
    }): Promise<NftMintAndOwner[]>;
    createFromMetadata(input: {
        network?: Network;
        metadataUri: string;
        maxSupply?: number;
        collectionAddress?: string;
        receiver: string;
        feePayer?: string;
        serviceCharge?: ServiceCharge;
    }): Promise<{
        encoded_transaction: string;
        mint: string;
    }>;
    burn(input: {
        network?: Network;
        wallet: string;
        mint: string;
        close?: boolean;
    }): Promise<string>;
    burnMany(input: {
        network?: Network;
        wallet: string;
        mints: string[];
        close?: boolean;
    }): Promise<string[]>;
    transfer(input: {
        network?: Network;
        mint: string;
        fromAddress: string;
        toAddress: string;
        transferAuthority?: boolean;
    }): Promise<string>;
    transferMultiple(input: {
        network?: Network;
        mints: string[];
        fromAddress: string;
        toAddress: string;
    }): Promise<string[]>;
    createV2(input: {
        network?: Network;
        creatorWallet: string;
        name: string;
        symbol: string;
        description?: string;
        attributes?: Attribute[];
        externalUrl?: string;
        maxSupply?: number;
        royalty?: number;
        collectionAddress?: string;
        feePayer?: string;
        image: File;
        data?: File;
    }): Promise<{
        encoded_transaction: string;
        mint: string;
    }>;
    updateV2(input: {
        network?: Network;
        mint: string;
        updateAuthority: string;
        name?: string;
        symbol?: string;
        description?: string;
        attributes?: Attribute[];
        royalty?: number;
        image?: File;
        data?: File;
        feePayer?: string;
        serviceCharge?: ServiceCharge;
    }): Promise<{
        encoded_transaction: string;
        mint: string;
    }>;
}
