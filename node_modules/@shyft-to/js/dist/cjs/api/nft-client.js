"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftClient = void 0;
const form_data_1 = __importDefault(require("form-data"));
const utils_1 = require("../utils");
const collection_client_1 = require("./collection-client");
const compressed_nft_client_1 = require("./compressed-nft-client");
const lodash_1 = require("lodash");
class NftClient {
    constructor(config) {
        this.config = config;
        this.collection = new collection_client_1.CollectionClient(this.config);
        this.compressed = new compressed_nft_client_1.CompressedNftClient(this.config);
    }
    getNftByMint(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const params = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    token_address: input.mint,
                };
                if (input.refresh) {
                    params['refresh'] = input.refresh;
                }
                if (input.tokenRecord) {
                    params['token_record'] = input.tokenRecord;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'get',
                    url: 'nft/read',
                    params,
                });
                const nft = data.result;
                return nft;
            }
            catch (error) {
                throw error;
            }
        });
    }
    getNftsByMintAddresses(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (input.mints.length === 0) {
                    throw new Error('At least one mint address is required');
                }
                if (input.mints.length > 10) {
                    throw new Error('Allowed between 1 to 10: mints');
                }
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    token_addresses: input.mints,
                };
                if (input.refresh) {
                    reqBody['refresh'] = input.refresh;
                }
                if (input.tokenRecord) {
                    reqBody['token_record'] = input.tokenRecord;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/read_selected',
                    data: reqBody,
                });
                const nfts = data.result;
                return nfts;
            }
            catch (error) {
                throw error;
            }
        });
    }
    getNftByOwner(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const params = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    address: input.owner,
                };
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'get',
                    url: 'nft/read_all',
                    params,
                });
                const nft = data.result;
                return nft;
            }
            catch (error) {
                throw error;
            }
        });
    }
    getNftsByOwnerV2(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const params = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    address: input.owner,
                };
                if (input.updateAuthority) {
                    params['update_authority'] = input.updateAuthority;
                }
                if (input.refresh) {
                    params['refresh'] = input.refresh;
                }
                if ((0, lodash_1.isNumber)(input === null || input === void 0 ? void 0 : input.page)) {
                    if (input.page < 1) {
                        throw new Error('should not be less than 1: size');
                    }
                    params['page'] = input.page;
                }
                if ((0, lodash_1.isNumber)(input === null || input === void 0 ? void 0 : input.size)) {
                    if (input.size > 50 || input.size < 1) {
                        throw new Error('allowed between 1 to 50: size');
                    }
                    params['size'] = input.size;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'get',
                    url: 'nft/read_all',
                    params,
                }, 'v2');
                const nft = data.result;
                return nft;
            }
            catch (error) {
                throw error;
            }
        });
    }
    getOwners(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (input.mints.length < 1 || input.mints.length > 10) {
                    throw new Error('allowed between 1 to 10: mints');
                }
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    nft_addresses: input.mints,
                };
                const response = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/get_owners',
                    data: reqBody,
                });
                const nftMintsAndOwners = response.result;
                return nftMintsAndOwners;
            }
            catch (error) {
                throw error;
            }
        });
    }
    createFromMetadata(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    metadata_uri: input.metadataUri,
                    receiver: input.receiver,
                };
                if (input === null || input === void 0 ? void 0 : input.maxSupply) {
                    reqBody['max_supply'] = input.maxSupply;
                }
                if (input === null || input === void 0 ? void 0 : input.collectionAddress) {
                    reqBody['collection_address'] = input.collectionAddress;
                }
                if (input === null || input === void 0 ? void 0 : input.feePayer) {
                    reqBody['fee_payer'] = input.feePayer;
                }
                if (input === null || input === void 0 ? void 0 : input.serviceCharge) {
                    reqBody['service_charge'] = input.serviceCharge;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/create_from_metadata',
                    data: reqBody,
                });
                const result = data.result;
                return result;
            }
            catch (error) {
                throw error;
            }
        });
    }
    burn(input) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    wallet: input.wallet,
                    token_address: input.mint,
                };
                if (input === null || input === void 0 ? void 0 : input.close) {
                    reqBody['close'] = input.close;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'delete',
                    url: 'nft/burn_detach',
                    data: reqBody,
                });
                const encodedTransaction = (_b = data.result) === null || _b === void 0 ? void 0 : _b.encoded_transaction;
                return encodedTransaction;
            }
            catch (error) {
                throw error;
            }
        });
    }
    burnMany(input) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    wallet: input.wallet,
                    nft_addresses: input.mints,
                };
                if (input === null || input === void 0 ? void 0 : input.close) {
                    reqBody['close_accounts'] = input.close;
                }
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'delete',
                    url: 'nft/burn_many',
                    data: reqBody,
                });
                const encodedTransactions = (_b = data.result) === null || _b === void 0 ? void 0 : _b.encoded_transactions;
                return encodedTransactions;
            }
            catch (error) {
                throw error;
            }
        });
    }
    transfer(input) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    token_address: input.mint,
                    from_address: input.fromAddress,
                    to_address: input.toAddress,
                    transfer_authority: (_b = input === null || input === void 0 ? void 0 : input.transferAuthority) !== null && _b !== void 0 ? _b : false,
                };
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/transfer_detach',
                    data: reqBody,
                });
                const encodedTransaction = (_c = data.result) === null || _c === void 0 ? void 0 : _c.encoded_transaction;
                return encodedTransaction;
            }
            catch (error) {
                throw error;
            }
        });
    }
    transferMultiple(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqBody = {
                    network: (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network,
                    token_addresses: input.mints,
                    from_address: input.fromAddress,
                    to_address: input.toAddress,
                };
                const data = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/transfer_many',
                    data: reqBody,
                });
                const encodedTransactions = data.result.encoded_transactions;
                return encodedTransactions;
            }
            catch (error) {
                throw error;
            }
        });
    }
    createV2(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let data = new form_data_1.default();
                data.append('network', (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network);
                data.append('creator_wallet', input.creatorWallet);
                data.append('name', input.name);
                data.append('symbol', input.symbol);
                if (input === null || input === void 0 ? void 0 : input.description) {
                    data.append('description', input.description);
                }
                if (input === null || input === void 0 ? void 0 : input.attributes) {
                    data.append('attributes', JSON.stringify(input.attributes));
                }
                if (input === null || input === void 0 ? void 0 : input.externalUrl) {
                    data.append('external_url', input.externalUrl);
                }
                if (input === null || input === void 0 ? void 0 : input.maxSupply) {
                    data.append('max_supply', input.maxSupply.toString());
                }
                if (input === null || input === void 0 ? void 0 : input.royalty) {
                    data.append('royalty', input.royalty.toString());
                }
                if (input === null || input === void 0 ? void 0 : input.collectionAddress) {
                    data.append('collection_address', input.collectionAddress);
                }
                if (input === null || input === void 0 ? void 0 : input.feePayer) {
                    data.append('fee_payer', input.feePayer);
                }
                data.append('image', input.image);
                if (input === null || input === void 0 ? void 0 : input.data) {
                    data.append('data', input.data);
                }
                const response = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/create',
                    maxBodyLength: Infinity,
                    data,
                }, 'v2');
                const result = response.result;
                return result;
            }
            catch (error) {
                throw error;
            }
        });
    }
    updateV2(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let data = new form_data_1.default();
                data.append('network', (_a = input.network) !== null && _a !== void 0 ? _a : this.config.network);
                data.append('token_address', input.mint);
                data.append('update_authority_address', input.updateAuthority);
                if (input === null || input === void 0 ? void 0 : input.name) {
                    if (input.name.length > 32) {
                        throw new Error('Max length allowed 32: name');
                    }
                    data.append('name', input.name);
                }
                if (input === null || input === void 0 ? void 0 : input.symbol) {
                    if (input.symbol.length > 10) {
                        throw new Error('Max length allowed 10: symbol');
                    }
                    data.append('symbol', input.symbol);
                }
                if (input === null || input === void 0 ? void 0 : input.description) {
                    data.append('description', input.description);
                }
                if (input === null || input === void 0 ? void 0 : input.attributes) {
                    data.append('attributes', JSON.stringify(input.attributes));
                }
                if (input === null || input === void 0 ? void 0 : input.royalty) {
                    data.append('royalty', input.royalty.toString());
                }
                if (input === null || input === void 0 ? void 0 : input.image) {
                    data.append('image', input.image);
                }
                if (input === null || input === void 0 ? void 0 : input.data) {
                    data.append('data', input.data);
                }
                if (input === null || input === void 0 ? void 0 : input.feePayer) {
                    data.append('fee_payer', input.feePayer);
                }
                if (input === null || input === void 0 ? void 0 : input.serviceCharge) {
                    data.append('service_charge', input.serviceCharge);
                }
                const response = yield (0, utils_1.restApiCall)(this.config.apiKey, {
                    method: 'post',
                    url: 'nft/update',
                    maxBodyLength: Infinity,
                    data,
                }, 'v2');
                const result = {
                    encoded_transaction: response.result,
                    mint: input.mint,
                };
                return result;
            }
            catch (error) {
                throw error;
            }
        });
    }
}
exports.NftClient = NftClient;
//# sourceMappingURL=nft-client.js.map