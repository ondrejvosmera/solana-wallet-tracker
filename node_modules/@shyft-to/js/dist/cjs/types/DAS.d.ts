export declare enum Interface {
    V1NFT = "V1_NFT",
    CUSTOM = "Custom",
    V1PRINT = "V1_PRINT",
    LEGACYNFT = "Legacy_NFT",
    V2NFT = "V2_NFT",
    FUNGIBLE_ASSET = "FungibleAsset",
    IDENTITY = "Identity",
    EXECUTABLE = "Executable",
    PROGRAMMABLENFT = "ProgrammableNFT"
}
export declare enum Scope {
    FULL = "full",
    ROYALTY = "royalty",
    METADATA = "metadata",
    EXTENSION = "extension"
}
export declare enum Context {
    WalletDefault = "wallet-default",
    WebDesktop = "web-desktop",
    WebMobile = "web-mobile",
    AppMobile = "app-mobile",
    AppDesktop = "app-desktop",
    App = "app",
    Vr = "vr"
}
export declare enum OwnershipModel {
    SINGLE = "single",
    TOKEN = "token"
}
export declare enum RoyaltyModel {
    CREATORS = "creators",
    FANOUT = "fanout",
    SINGLE = "single"
}
export declare enum UseMethods {
    BURN = "Burn",
    SINGLE = "Single",
    MULTIPLE = "Multiple"
}
export declare type AssetSortBy = 'created' | 'updated' | 'recent_action';
export declare type AssetSortDirection = 'asc' | 'desc';
export declare namespace DAS {
    interface AssetsByOwnerRequest {
        ownerAddress: string;
        page: number;
        limit?: number;
        before?: string;
        after?: string;
        displayOptions?: DisplayOptions;
        sortBy?: AssetSortingRequest;
    }
    type AssetsByCreatorRequest = {
        creatorAddress: string;
        page: number;
        onlyVerified?: boolean;
        limit?: number;
        before?: string;
        after?: string;
        displayOptions?: DisplayOptions;
        sortBy?: AssetSortingRequest;
    };
    type GetAssetBatchRequest = {
        ids: Array<string>;
        displayOptions?: GetAssetDisplayOptions;
    };
    type AssetsByGroupRequest = {
        groupValue: string;
        groupKey: string;
        page: number;
        limit?: number;
        before?: string;
        after?: string;
        displayOptions?: DisplayOptions;
        sortBy?: AssetSortingRequest;
    };
    type GetAssetsBatchRequest = {
        ids: string[];
    };
    interface SearchAssetsRequest {
        page: number;
        limit?: number;
        before?: string;
        after?: string;
        creatorAddress?: string;
        ownerAddress?: string;
        jsonUri?: string;
        grouping?: string[];
        burnt?: boolean;
        sortBy?: AssetSortingRequest;
        frozen?: boolean;
        supplyMint?: string;
        supply?: number;
        interface?: string;
        delegate?: number;
        ownerType?: OwnershipModel;
        royaltyAmount?: number;
        royaltyTarget?: string;
        royaltyTargetType?: RoyaltyModel;
        compressible?: boolean;
        compressed?: boolean;
    }
    type AssetsByAuthorityRequest = {
        authorityAddress: string;
        page: number;
        limit?: number;
        before?: string;
        after?: string;
        displayOptions?: DisplayOptions;
        sortBy?: AssetSortingRequest;
    };
    type GetAssetRequest = {
        id: string;
        displayOptions?: GetAssetDisplayOptions;
    };
    type GetAssetProofRequest = {
        id: string;
    };
    type GetSignaturesForAssetRequest = {
        id: string;
        page: number;
        limit?: number;
        before?: string;
        after?: string;
    };
    interface AssetSorting {
        sort_by: AssetSortBy;
        sort_direction: AssetSortDirection;
    }
    type AssetSortingRequest = {
        sortBy: AssetSortBy;
        sortDirection: AssetSortDirection;
    };
    type GetAssetResponse = {
        interface: Interface;
        id: string;
        content?: Content;
        authorities?: Authorities[];
        compression?: Compression;
        grouping?: Grouping[];
        royalty?: Royalty;
        ownership: Ownership;
        creators?: Creators[];
        uses?: Uses;
        supply?: Supply;
        mutable: boolean;
        burnt: boolean;
    };
    type GetAssetResponseList = {
        grand_total?: boolean;
        total: number;
        limit: number;
        page: number;
        items: GetAssetResponse[];
    };
    interface GetAssetProofResponse {
        root: string;
        proof: Array<string>;
        node_index: number;
        leaf: string;
        tree_id: string;
    }
    interface GetSignaturesForAssetResponse {
        total: number;
        limit: number;
        page?: number;
        before?: string;
        after?: string;
        items: Array<Array<string>>;
    }
    type DisplayOptions = {
        showUnverifiedCollections?: boolean;
        showCollectionMetadata?: boolean;
        showGrandTotal?: boolean;
    };
    type GetAssetDisplayOptions = {
        showUnverifiedCollections?: boolean;
        showCollectionMetadata?: boolean;
    };
    interface Ownership {
        frozen: boolean;
        delegated: boolean;
        delegate?: string;
        ownership_model: OwnershipModel;
        owner: string;
    }
    interface Supply {
        print_max_supply: number;
        print_current_supply: number;
        edition_nonce?: number;
    }
    interface Uses {
        use_method: UseMethods;
        remaining: number;
        total: number;
    }
    interface Creators {
        address: string;
        share: number;
        verified: boolean;
    }
    interface Royalty {
        royalty_model: RoyaltyModel;
        target?: string;
        percent: number;
        basis_points: number;
        primary_sale_happened: boolean;
        locked: boolean;
    }
    interface Grouping {
        group_key: string;
        group_value: string;
        verified?: boolean;
        collection_metadata?: CollectionMetadata;
    }
    interface CollectionMetadata {
        name?: string;
        symbol?: string;
        image?: string;
        description?: string;
        external_url?: string;
    }
    interface Authorities {
        address: string;
        scopes: Array<Scope>;
    }
    type Links = {
        external_url?: string;
        image?: string;
        animation_url?: string;
        [Symbol.iterator](): Iterator<Links>;
    };
    interface Content {
        $schema: string;
        json_uri: string;
        files?: Files;
        metadata: Metadata;
        links?: Links;
    }
    interface File {
        uri?: string;
        mime?: string;
        cdn_uri?: string;
        quality?: FileQuality;
        contexts?: Context[];
        [Symbol.iterator](): Iterator<File>;
    }
    type Files = File[];
    interface FileQuality {
        schema: string;
    }
    interface Metadata {
        attributes?: Attribute[];
        description: string;
        name: string;
        symbol: string;
    }
    interface Attribute {
        value: string;
        trait_type: string;
    }
    interface Compression {
        eligible: boolean;
        compressed: boolean;
        data_hash: string;
        creator_hash: string;
        asset_hash: string;
        tree: string;
        seq: number;
        leaf_id: number;
    }
}
