"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.partialSignTransactionWithPrivateKeys = exports.signAndSendTransaction = exports.signAndSendTransactionWithPrivateKeys = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = require("bs58");
/**
 * This function accepts the connection to the user’s wallet,
 * the encodedTransaction received in the response of the API call and the wallet object.
 * The only difference is, along with these parameters,
 * this function also takes in an array of private keys,
 * which can contain all the private keys required to partially sign the transaction.
 *
 * @param network solana rpc network (mainnet-beta/devnet/testnet)
 * @param encodedTransaction serialized transaction (base64 string)
 * @param privateKeys private key of wallets (Array of strings)
 * @returns transaction signature
 */
function signAndSendTransactionWithPrivateKeys(network, encodedTransaction, privateKeys) {
    return __awaiter(this, void 0, void 0, function* () {
        const connection = new web3_js_1.Connection((0, web3_js_1.clusterApiUrl)(network), 'confirmed');
        const signedTxn = yield partialSignTransactionWithPrivateKeys(encodedTransaction, privateKeys);
        const signature = yield connection.sendRawTransaction(signedTxn.serialize());
        return signature;
    });
}
exports.signAndSendTransactionWithPrivateKeys = signAndSendTransactionWithPrivateKeys;
/**
 * This function accepts connection, the encoded_transaction from the SHYFT API response and the wallet object.
 * The wallet object and the connection to the user’s wallet can be obtained.
 *
 * @param connection solana rpc connection
 * @param encodedTransaction serialized transaction (base64 string)
 * @param wallet wallet
 * @returns transaction signature
 */
function signAndSendTransaction(connection, encodedTransaction, wallet) {
    return __awaiter(this, void 0, void 0, function* () {
        const recoveredTransaction = getRawTransaction(encodedTransaction);
        const signedTx = yield wallet.signTransaction(recoveredTransaction);
        const confirmTransaction = yield connection.sendRawTransaction(signedTx.serialize());
        return confirmTransaction;
    });
}
exports.signAndSendTransaction = signAndSendTransaction;
/**
 * This function accepts the encodedTransaction received
 * in the response of the API call and takes an array of private keys,
 * which can contain all the private keys required to partially sign the transaction.
 * Could be useful when a transaction has required multiple signature to further proceed.
 *
 * @param encodedTransaction serialized transaction (base64 string)
 * @param privateKeys private keys of wallet (array of string)
 * @returns Raw transaction
 */
function partialSignTransactionWithPrivateKeys(encodedTransaction, privateKeys) {
    return __awaiter(this, void 0, void 0, function* () {
        const recoveredTransaction = getRawTransaction(encodedTransaction);
        const signers = getSignersFromPrivateKeys(privateKeys);
        if (recoveredTransaction instanceof web3_js_1.VersionedTransaction) {
            recoveredTransaction.sign(signers);
        }
        else {
            recoveredTransaction.partialSign(...signers);
        }
        return recoveredTransaction;
    });
}
exports.partialSignTransactionWithPrivateKeys = partialSignTransactionWithPrivateKeys;
function getSignersFromPrivateKeys(privateKeys) {
    return privateKeys.map((privateKey) => {
        const signer = web3_js_1.Keypair.fromSecretKey((0, bs58_1.decode)(privateKey));
        return signer;
    });
}
function getRawTransaction(encodedTransaction) {
    let recoveredTransaction;
    try {
        recoveredTransaction = web3_js_1.Transaction.from(Buffer.from(encodedTransaction, 'base64'));
    }
    catch (error) {
        recoveredTransaction = web3_js_1.VersionedTransaction.deserialize(Buffer.from(encodedTransaction, 'base64'));
    }
    return recoveredTransaction;
}
//# sourceMappingURL=signer.js.map