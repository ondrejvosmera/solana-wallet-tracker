/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-loading";
exports.ids = ["vendor-chunks/react-loading"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-loading/dist/react-loading.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-loading/dist/react-loading.js ***!
  \**********************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(typeof self !== \"undefined\" ? self : this, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_592__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_592__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_592__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_592__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_592__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_592__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_592__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_592__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_592__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_592__.p = \"/\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_592__(__nested_webpack_require_592__.s = 7);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ /**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */ var validateFormat = function validateFormat(format) {};\n            if (true) {\n                validateFormat = function validateFormat(format) {\n                    if (format === undefined) {\n                        throw new Error(\"invariant requires an error message argument\");\n                    }\n                };\n            }\n            function invariant(condition, format, a, b, c, d, e, f) {\n                validateFormat(format);\n                if (!condition) {\n                    var error;\n                    if (format === undefined) {\n                        error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n                    } else {\n                        var args = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        var argIndex = 0;\n                        error = new Error(format.replace(/%s/g, function() {\n                            return args[argIndex++];\n                        }));\n                        error.name = \"Invariant Violation\";\n                    }\n                    error.framesToPop = 1; // we don't care about invariant's own frame\n                    throw error;\n                }\n            }\n            module1.exports = invariant;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */ function makeEmptyFunction(arg) {\n                return function() {\n                    return arg;\n                };\n            }\n            /**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */ var emptyFunction = function emptyFunction() {};\n            emptyFunction.thatReturns = makeEmptyFunction;\n            emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n            emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n            emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n            emptyFunction.thatReturnsThis = function() {\n                return this;\n            };\n            emptyFunction.thatReturnsArgument = function(arg) {\n                return arg;\n            };\n            module1.exports = emptyFunction;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n            var hasOwnProperty = Object.prototype.hasOwnProperty;\n            var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n            function toObject(val) {\n                if (val === null || val === undefined) {\n                    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n                }\n                return Object(val);\n            }\n            function shouldUseNative() {\n                try {\n                    if (!Object.assign) {\n                        return false;\n                    }\n                    // Detect buggy property enumeration order in older V8 versions.\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                    var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                    test1[5] = \"de\";\n                    if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                        return false;\n                    }\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                    var test2 = {};\n                    for(var i = 0; i < 10; i++){\n                        test2[\"_\" + String.fromCharCode(i)] = i;\n                    }\n                    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                        return test2[n];\n                    });\n                    if (order2.join(\"\") !== \"0123456789\") {\n                        return false;\n                    }\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                    var test3 = {};\n                    \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                        test3[letter] = letter;\n                    });\n                    if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                        return false;\n                    }\n                    return true;\n                } catch (err) {\n                    // We don't expect any of the above to throw, but better to be safe.\n                    return false;\n                }\n            }\n            module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n                var from;\n                var to = toObject(target);\n                var symbols;\n                for(var s = 1; s < arguments.length; s++){\n                    from = Object(arguments[s]);\n                    for(var key in from){\n                        if (hasOwnProperty.call(from, key)) {\n                            to[key] = from[key];\n                        }\n                    }\n                    if (getOwnPropertySymbols) {\n                        symbols = getOwnPropertySymbols(from);\n                        for(var i = 0; i < symbols.length; i++){\n                            if (propIsEnumerable.call(from, symbols[i])) {\n                                to[symbols[i]] = from[symbols[i]];\n                            }\n                        }\n                    }\n                }\n                return to;\n            };\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_10133__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ var emptyFunction = __nested_webpack_require_10133__(1);\n            /**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */ var warning = emptyFunction;\n            if (true) {\n                var printWarning = function printWarning(format) {\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var argIndex = 0;\n                    var message = \"Warning: \" + format.replace(/%s/g, function() {\n                        return args[argIndex++];\n                    });\n                    if (typeof console !== \"undefined\") {\n                        console.error(message);\n                    }\n                    try {\n                        // --- Welcome to debugging React ---\n                        // This error was thrown as a convenience so that you can use this stack\n                        // to find the callsite that caused this warning to fire.\n                        throw new Error(message);\n                    } catch (x) {}\n                };\n                warning = function warning(condition, format) {\n                    if (format === undefined) {\n                        throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                    }\n                    if (format.indexOf(\"Failed Composite propType: \") === 0) {\n                        return; // Ignore CompositeComponent proptype check.\n                    }\n                    if (!condition) {\n                        for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                            args[_key2 - 2] = arguments[_key2];\n                        }\n                        printWarning.apply(undefined, [\n                            format\n                        ].concat(args));\n                    }\n                };\n            }\n            module1.exports = warning;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n            module1.exports = ReactPropTypesSecret;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ var emptyObject = {};\n            if (true) {\n                Object.freeze(emptyObject);\n            }\n            module1.exports = emptyObject;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_13678__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                var invariant = __nested_webpack_require_13678__(0);\n                var warning = __nested_webpack_require_13678__(3);\n                var ReactPropTypesSecret = __nested_webpack_require_13678__(4);\n                var loggedTypeFailures = {};\n            }\n            /**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                if (true) {\n                    for(var typeSpecName in typeSpecs){\n                        if (typeSpecs.hasOwnProperty(typeSpecName)) {\n                            var error;\n                            // Prop type validation may throw. In case they do, we don't want to\n                            // fail the render phase where it didn't fail before. So we log it.\n                            // After these have been cleaned up, we'll let them throw.\n                            try {\n                                // This is intentionally an invariant that gets caught. It's the same\n                                // behavior as without this statement except with a better message.\n                                invariant(typeof typeSpecs[typeSpecName] === \"function\", \"%s: %s type `%s` is invalid; it must be a function, usually from \" + \"the `prop-types` package, but received `%s`.\", componentName || \"React class\", location, typeSpecName, typeof typeSpecs[typeSpecName]);\n                                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                            } catch (ex) {\n                                error = ex;\n                            }\n                            warning(!error || error instanceof Error, \"%s: type specification of %s `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error);\n                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                // Only monitor this failure once because there tends to be a lot of the\n                                // same error.\n                                loggedTypeFailures[error.message] = true;\n                                var stack = getStack ? getStack() : \"\";\n                                warning(false, \"Failed %s type: %s%s\", location, error.message, stack != null ? stack : \"\");\n                            }\n                        }\n                    }\n                }\n            }\n            module1.exports = checkPropTypes;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_17237__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _extends = Object.assign || function(target) {\n                for(var i = 1; i < arguments.length; i++){\n                    var source = arguments[i];\n                    for(var key in source){\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n                return target;\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _react = __nested_webpack_require_17237__(8);\n            var _react2 = _interopRequireDefault(_react);\n            var _propTypes = __nested_webpack_require_17237__(11);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _svg = __nested_webpack_require_17237__(14);\n            var svgSources = _interopRequireWildcard(_svg);\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                } else {\n                    var newObj = {};\n                    if (obj != null) {\n                        for(var key in obj){\n                            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n                        }\n                    }\n                    newObj.default = obj;\n                    return newObj;\n                }\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _objectWithoutProperties(obj, keys) {\n                var target = {};\n                for(var i in obj){\n                    if (keys.indexOf(i) >= 0) continue;\n                    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n                    target[i] = obj[i];\n                }\n                return target;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Loading = function(_Component) {\n                _inherits(Loading, _Component);\n                function Loading() {\n                    var _ref;\n                    var _temp, _this, _ret;\n                    _classCallCheck(this, Loading);\n                    for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Loading.__proto__ || Object.getPrototypeOf(Loading)).call.apply(_ref, [\n                        this\n                    ].concat(args))), _this), _this.state = {\n                        delayed: _this.props.delay > 0\n                    }, _temp), _possibleConstructorReturn(_this, _ret);\n                }\n                _createClass(Loading, [\n                    {\n                        key: \"componentDidMount\",\n                        value: function componentDidMount() {\n                            var _this2 = this;\n                            var delay = this.props.delay;\n                            var delayed = this.state.delayed;\n                            if (delayed) {\n                                this.timeout = setTimeout(function() {\n                                    _this2.setState({\n                                        delayed: false\n                                    });\n                                }, delay);\n                            }\n                        }\n                    },\n                    {\n                        key: \"componentWillUnmount\",\n                        value: function componentWillUnmount() {\n                            var timeout = this.timeout;\n                            if (timeout) {\n                                clearTimeout(timeout);\n                            }\n                        }\n                    },\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, color = _props.color, delay = _props.delay, type = _props.type, height = _props.height, width = _props.width, restProps = _objectWithoutProperties(_props, [\n                                \"color\",\n                                \"delay\",\n                                \"type\",\n                                \"height\",\n                                \"width\"\n                            ]);\n                            var selectedType = this.state.delayed ? \"blank\" : type;\n                            var svg = svgSources[selectedType];\n                            var style = {\n                                fill: color,\n                                height: height,\n                                width: width\n                            };\n                            return _react2.default.createElement(\"div\", _extends({\n                                style: style,\n                                dangerouslySetInnerHTML: {\n                                    __html: svg\n                                }\n                            }, restProps));\n                        }\n                    }\n                ]);\n                return Loading;\n            }(_react.Component);\n            Loading.propTypes = {\n                color: _propTypes2.default.string,\n                delay: _propTypes2.default.number,\n                type: _propTypes2.default.string,\n                height: _propTypes2.default.oneOfType([\n                    _propTypes2.default.string,\n                    _propTypes2.default.number\n                ]),\n                width: _propTypes2.default.oneOfType([\n                    _propTypes2.default.string,\n                    _propTypes2.default.number\n                ])\n            };\n            Loading.defaultProps = {\n                color: \"#fff\",\n                delay: 0,\n                type: \"balls\",\n                height: 64,\n                width: 64\n            };\n            exports1.default = Loading;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_25598__) {\n            \"use strict\";\n            if (false) {} else {\n                module1.exports = __nested_webpack_require_25598__(10);\n            }\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __nested_webpack_require_25916__) {\n            \"use strict\";\n            /** @license React v16.3.2\n * react.production.min.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var m = __nested_webpack_require_25916__(2), n = __nested_webpack_require_25916__(0), p = __nested_webpack_require_25916__(5), q = __nested_webpack_require_25916__(1), r = \"function\" === typeof Symbol && Symbol[\"for\"], t = r ? Symbol[\"for\"](\"react.element\") : 60103, u = r ? Symbol[\"for\"](\"react.portal\") : 60106, v = r ? Symbol[\"for\"](\"react.fragment\") : 60107, w = r ? Symbol[\"for\"](\"react.strict_mode\") : 60108, x = r ? Symbol[\"for\"](\"react.provider\") : 60109, y = r ? Symbol[\"for\"](\"react.context\") : 60110, z = r ? Symbol[\"for\"](\"react.async_mode\") : 60111, A = r ? Symbol[\"for\"](\"react.forward_ref\") : 60112, B = \"function\" === typeof Symbol && Symbol.iterator;\n            function C(a) {\n                for(var b = arguments.length - 1, e = \"http://reactjs.org/docs/error-decoder.html?invariant=\" + a, c = 0; c < b; c++)e += \"&args[]=\" + encodeURIComponent(arguments[c + 1]);\n                n(!1, \"Minified React error #\" + a + \"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. \", e);\n            }\n            var D = {\n                isMounted: function() {\n                    return !1;\n                },\n                enqueueForceUpdate: function() {},\n                enqueueReplaceState: function() {},\n                enqueueSetState: function() {}\n            };\n            function E(a, b, e) {\n                this.props = a;\n                this.context = b;\n                this.refs = p;\n                this.updater = e || D;\n            }\n            E.prototype.isReactComponent = {};\n            E.prototype.setState = function(a, b) {\n                \"object\" !== typeof a && \"function\" !== typeof a && null != a ? C(\"85\") : void 0;\n                this.updater.enqueueSetState(this, a, b, \"setState\");\n            };\n            E.prototype.forceUpdate = function(a) {\n                this.updater.enqueueForceUpdate(this, a, \"forceUpdate\");\n            };\n            function F() {}\n            F.prototype = E.prototype;\n            function G(a, b, e) {\n                this.props = a;\n                this.context = b;\n                this.refs = p;\n                this.updater = e || D;\n            }\n            var H = G.prototype = new F;\n            H.constructor = G;\n            m(H, E.prototype);\n            H.isPureReactComponent = !0;\n            var I = {\n                current: null\n            }, J = Object.prototype.hasOwnProperty, K = {\n                key: !0,\n                ref: !0,\n                __self: !0,\n                __source: !0\n            };\n            function L(a, b, e) {\n                var c = void 0, d = {}, g = null, h = null;\n                if (null != b) for(c in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (g = \"\" + b.key), b)J.call(b, c) && !K.hasOwnProperty(c) && (d[c] = b[c]);\n                var f = arguments.length - 2;\n                if (1 === f) d.children = e;\n                else if (1 < f) {\n                    for(var k = Array(f), l = 0; l < f; l++)k[l] = arguments[l + 2];\n                    d.children = k;\n                }\n                if (a && a.defaultProps) for(c in f = a.defaultProps, f)void 0 === d[c] && (d[c] = f[c]);\n                return {\n                    $$typeof: t,\n                    type: a,\n                    key: g,\n                    ref: h,\n                    props: d,\n                    _owner: I.current\n                };\n            }\n            function M(a) {\n                return \"object\" === typeof a && null !== a && a.$$typeof === t;\n            }\n            function escape(a) {\n                var b = {\n                    \"=\": \"=0\",\n                    \":\": \"=2\"\n                };\n                return \"$\" + (\"\" + a).replace(/[=:]/g, function(a) {\n                    return b[a];\n                });\n            }\n            var N = /\\/+/g, O = [];\n            function P(a, b, e, c) {\n                if (O.length) {\n                    var d = O.pop();\n                    d.result = a;\n                    d.keyPrefix = b;\n                    d.func = e;\n                    d.context = c;\n                    d.count = 0;\n                    return d;\n                }\n                return {\n                    result: a,\n                    keyPrefix: b,\n                    func: e,\n                    context: c,\n                    count: 0\n                };\n            }\n            function Q(a) {\n                a.result = null;\n                a.keyPrefix = null;\n                a.func = null;\n                a.context = null;\n                a.count = 0;\n                10 > O.length && O.push(a);\n            }\n            function R(a, b, e, c) {\n                var d = typeof a;\n                if (\"undefined\" === d || \"boolean\" === d) a = null;\n                var g = !1;\n                if (null === a) g = !0;\n                else switch(d){\n                    case \"string\":\n                    case \"number\":\n                        g = !0;\n                        break;\n                    case \"object\":\n                        switch(a.$$typeof){\n                            case t:\n                            case u:\n                                g = !0;\n                        }\n                }\n                if (g) return e(c, a, \"\" === b ? \".\" + S(a, 0) : b), 1;\n                g = 0;\n                b = \"\" === b ? \".\" : b + \":\";\n                if (Array.isArray(a)) for(var h = 0; h < a.length; h++){\n                    d = a[h];\n                    var f = b + S(d, h);\n                    g += R(d, f, e, c);\n                }\n                else if (null === a || \"undefined\" === typeof a ? f = null : (f = B && a[B] || a[\"@@iterator\"], f = \"function\" === typeof f ? f : null), \"function\" === typeof f) for(a = f.call(a), h = 0; !(d = a.next()).done;)d = d.value, f = b + S(d, h++), g += R(d, f, e, c);\n                else \"object\" === d && (e = \"\" + a, C(\"31\", \"[object Object]\" === e ? \"object with keys {\" + Object.keys(a).join(\", \") + \"}\" : e, \"\"));\n                return g;\n            }\n            function S(a, b) {\n                return \"object\" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);\n            }\n            function T(a, b) {\n                a.func.call(a.context, b, a.count++);\n            }\n            function U(a, b, e) {\n                var c = a.result, d = a.keyPrefix;\n                a = a.func.call(a.context, b, a.count++);\n                Array.isArray(a) ? V(a, c, e, q.thatReturnsArgument) : null != a && (M(a) && (b = d + (!a.key || b && b.key === a.key ? \"\" : (\"\" + a.key).replace(N, \"$&/\") + \"/\") + e, a = {\n                    $$typeof: t,\n                    type: a.type,\n                    key: b,\n                    ref: a.ref,\n                    props: a.props,\n                    _owner: a._owner\n                }), c.push(a));\n            }\n            function V(a, b, e, c, d) {\n                var g = \"\";\n                null != e && (g = (\"\" + e).replace(N, \"$&/\") + \"/\");\n                b = P(b, g, c, d);\n                null == a || R(a, \"\", U, b);\n                Q(b);\n            }\n            var W = {\n                Children: {\n                    map: function(a, b, e) {\n                        if (null == a) return a;\n                        var c = [];\n                        V(a, c, null, b, e);\n                        return c;\n                    },\n                    forEach: function(a, b, e) {\n                        if (null == a) return a;\n                        b = P(null, null, b, e);\n                        null == a || R(a, \"\", T, b);\n                        Q(b);\n                    },\n                    count: function(a) {\n                        return null == a ? 0 : R(a, \"\", q.thatReturnsNull, null);\n                    },\n                    toArray: function(a) {\n                        var b = [];\n                        V(a, b, null, q.thatReturnsArgument);\n                        return b;\n                    },\n                    only: function(a) {\n                        M(a) ? void 0 : C(\"143\");\n                        return a;\n                    }\n                },\n                createRef: function() {\n                    return {\n                        current: null\n                    };\n                },\n                Component: E,\n                PureComponent: G,\n                createContext: function(a, b) {\n                    void 0 === b && (b = null);\n                    a = {\n                        $$typeof: y,\n                        _calculateChangedBits: b,\n                        _defaultValue: a,\n                        _currentValue: a,\n                        _changedBits: 0,\n                        Provider: null,\n                        Consumer: null\n                    };\n                    a.Provider = {\n                        $$typeof: x,\n                        _context: a\n                    };\n                    return a.Consumer = a;\n                },\n                forwardRef: function(a) {\n                    return {\n                        $$typeof: A,\n                        render: a\n                    };\n                },\n                Fragment: v,\n                StrictMode: w,\n                unstable_AsyncMode: z,\n                createElement: L,\n                cloneElement: function(a, b, e) {\n                    null === a || void 0 === a ? C(\"267\", a) : void 0;\n                    var c = void 0, d = m({}, a.props), g = a.key, h = a.ref, f = a._owner;\n                    if (null != b) {\n                        void 0 !== b.ref && (h = b.ref, f = I.current);\n                        void 0 !== b.key && (g = \"\" + b.key);\n                        var k = void 0;\n                        a.type && a.type.defaultProps && (k = a.type.defaultProps);\n                        for(c in b)J.call(b, c) && !K.hasOwnProperty(c) && (d[c] = void 0 === b[c] && void 0 !== k ? k[c] : b[c]);\n                    }\n                    c = arguments.length - 2;\n                    if (1 === c) d.children = e;\n                    else if (1 < c) {\n                        k = Array(c);\n                        for(var l = 0; l < c; l++)k[l] = arguments[l + 2];\n                        d.children = k;\n                    }\n                    return {\n                        $$typeof: t,\n                        type: a.type,\n                        key: g,\n                        ref: h,\n                        props: d,\n                        _owner: f\n                    };\n                },\n                createFactory: function(a) {\n                    var b = L.bind(null, a);\n                    b.type = a;\n                    return b;\n                },\n                isValidElement: M,\n                version: \"16.3.2\",\n                __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n                    ReactCurrentOwner: I,\n                    assign: m\n                }\n            }, X = Object.freeze({\n                default: W\n            }), Y = X && W || X;\n            module1.exports = Y[\"default\"] ? Y[\"default\"] : Y;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __nested_webpack_require_37431__) {\n            \"use strict\";\n            /** @license React v16.3.2\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                (function() {\n                    \"use strict\";\n                    var _assign = __nested_webpack_require_37431__(2);\n                    var invariant = __nested_webpack_require_37431__(0);\n                    var emptyObject = __nested_webpack_require_37431__(5);\n                    var warning = __nested_webpack_require_37431__(3);\n                    var emptyFunction = __nested_webpack_require_37431__(1);\n                    var checkPropTypes = __nested_webpack_require_37431__(6);\n                    // TODO: this is special because it gets imported during build.\n                    var ReactVersion = \"16.3.2\";\n                    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n                    // nor polyfill, then a plain number is used for performance.\n                    var hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"];\n                    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.element\") : 0xeac7;\n                    var REACT_CALL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.call\") : 0xeac8;\n                    var REACT_RETURN_TYPE = hasSymbol ? Symbol[\"for\"](\"react.return\") : 0xeac9;\n                    var REACT_PORTAL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.portal\") : 0xeaca;\n                    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.fragment\") : 0xeacb;\n                    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol[\"for\"](\"react.strict_mode\") : 0xeacc;\n                    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol[\"for\"](\"react.provider\") : 0xeacd;\n                    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.context\") : 0xeace;\n                    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol[\"for\"](\"react.async_mode\") : 0xeacf;\n                    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol[\"for\"](\"react.forward_ref\") : 0xead0;\n                    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                    var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n                    function getIteratorFn(maybeIterable) {\n                        if (maybeIterable === null || typeof maybeIterable === \"undefined\") {\n                            return null;\n                        }\n                        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n                        if (typeof maybeIterator === \"function\") {\n                            return maybeIterator;\n                        }\n                        return null;\n                    }\n                    // Relying on the `invariant()` implementation lets us\n                    // have preserve the format and params in the www builds.\n                    /**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */ var lowPriorityWarning = function() {};\n                    {\n                        var printWarning = function(format) {\n                            for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                args[_key - 1] = arguments[_key];\n                            }\n                            var argIndex = 0;\n                            var message = \"Warning: \" + format.replace(/%s/g, function() {\n                                return args[argIndex++];\n                            });\n                            if (typeof console !== \"undefined\") {\n                                console.warn(message);\n                            }\n                            try {\n                                // --- Welcome to debugging React ---\n                                // This error was thrown as a convenience so that you can use this stack\n                                // to find the callsite that caused this warning to fire.\n                                throw new Error(message);\n                            } catch (x) {}\n                        };\n                        lowPriorityWarning = function(condition, format) {\n                            if (format === undefined) {\n                                throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                            }\n                            if (!condition) {\n                                for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                                    args[_key2 - 2] = arguments[_key2];\n                                }\n                                printWarning.apply(undefined, [\n                                    format\n                                ].concat(args));\n                            }\n                        };\n                    }\n                    var lowPriorityWarning$1 = lowPriorityWarning;\n                    var didWarnStateUpdateForUnmountedComponent = {};\n                    function warnNoop(publicInstance, callerName) {\n                        {\n                            var _constructor = publicInstance.constructor;\n                            var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n                            var warningKey = componentName + \".\" + callerName;\n                            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n                                return;\n                            }\n                            warning(false, \"Can't call %s on a component that is not yet mounted. \" + \"This is a no-op, but it might indicate a bug in your application. \" + \"Instead, assign to `this.state` directly or define a `state = {};` \" + \"class property with the desired state in the %s component.\", callerName, componentName);\n                            didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n                        }\n                    }\n                    /**\n * This is the abstract API for an update queue.\n */ var ReactNoopUpdateQueue = {\n                        /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */ isMounted: function(publicInstance) {\n                            return false;\n                        },\n                        /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueForceUpdate: function(publicInstance, callback, callerName) {\n                            warnNoop(publicInstance, \"forceUpdate\");\n                        },\n                        /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n                            warnNoop(publicInstance, \"replaceState\");\n                        },\n                        /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */ enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n                            warnNoop(publicInstance, \"setState\");\n                        }\n                    };\n                    /**\n * Base class helpers for the updating state of a component.\n */ function Component(props, context, updater) {\n                        this.props = props;\n                        this.context = context;\n                        this.refs = emptyObject;\n                        // We initialize the default updater but the real one gets injected by the\n                        // renderer.\n                        this.updater = updater || ReactNoopUpdateQueue;\n                    }\n                    Component.prototype.isReactComponent = {};\n                    /**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */ Component.prototype.setState = function(partialState, callback) {\n                        !(typeof partialState === \"object\" || typeof partialState === \"function\" || partialState == null) ? invariant(false, \"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\") : void 0;\n                        this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n                    };\n                    /**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */ Component.prototype.forceUpdate = function(callback) {\n                        this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n                    };\n                    /**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */ {\n                        var deprecatedAPIs = {\n                            isMounted: [\n                                \"isMounted\",\n                                \"Instead, make sure to clean up subscriptions and pending requests in \" + \"componentWillUnmount to prevent memory leaks.\"\n                            ],\n                            replaceState: [\n                                \"replaceState\",\n                                \"Refactor your code to use setState instead (see \" + \"https://github.com/facebook/react/issues/3236).\"\n                            ]\n                        };\n                        var defineDeprecationWarning = function(methodName, info) {\n                            Object.defineProperty(Component.prototype, methodName, {\n                                get: function() {\n                                    lowPriorityWarning$1(false, \"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n                                    return undefined;\n                                }\n                            });\n                        };\n                        for(var fnName in deprecatedAPIs){\n                            if (deprecatedAPIs.hasOwnProperty(fnName)) {\n                                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n                            }\n                        }\n                    }\n                    function ComponentDummy() {}\n                    ComponentDummy.prototype = Component.prototype;\n                    /**\n * Convenience component with default shallow equality check for sCU.\n */ function PureComponent(props, context, updater) {\n                        this.props = props;\n                        this.context = context;\n                        this.refs = emptyObject;\n                        this.updater = updater || ReactNoopUpdateQueue;\n                    }\n                    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n                    pureComponentPrototype.constructor = PureComponent;\n                    // Avoid an extra prototype jump for these methods.\n                    _assign(pureComponentPrototype, Component.prototype);\n                    pureComponentPrototype.isPureReactComponent = true;\n                    // an immutable object with a single mutable value\n                    function createRef() {\n                        var refObject = {\n                            current: null\n                        };\n                        {\n                            Object.seal(refObject);\n                        }\n                        return refObject;\n                    }\n                    /**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */ var ReactCurrentOwner = {\n                        /**\n   * @internal\n   * @type {ReactComponent}\n   */ current: null\n                    };\n                    var hasOwnProperty = Object.prototype.hasOwnProperty;\n                    var RESERVED_PROPS = {\n                        key: true,\n                        ref: true,\n                        __self: true,\n                        __source: true\n                    };\n                    var specialPropKeyWarningShown = void 0;\n                    var specialPropRefWarningShown = void 0;\n                    function hasValidRef(config) {\n                        {\n                            if (hasOwnProperty.call(config, \"ref\")) {\n                                var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                                if (getter && getter.isReactWarning) {\n                                    return false;\n                                }\n                            }\n                        }\n                        return config.ref !== undefined;\n                    }\n                    function hasValidKey(config) {\n                        {\n                            if (hasOwnProperty.call(config, \"key\")) {\n                                var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                                if (getter && getter.isReactWarning) {\n                                    return false;\n                                }\n                            }\n                        }\n                        return config.key !== undefined;\n                    }\n                    function defineKeyPropWarningGetter(props, displayName) {\n                        var warnAboutAccessingKey = function() {\n                            if (!specialPropKeyWarningShown) {\n                                specialPropKeyWarningShown = true;\n                                warning(false, \"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://fb.me/react-special-props)\", displayName);\n                            }\n                        };\n                        warnAboutAccessingKey.isReactWarning = true;\n                        Object.defineProperty(props, \"key\", {\n                            get: warnAboutAccessingKey,\n                            configurable: true\n                        });\n                    }\n                    function defineRefPropWarningGetter(props, displayName) {\n                        var warnAboutAccessingRef = function() {\n                            if (!specialPropRefWarningShown) {\n                                specialPropRefWarningShown = true;\n                                warning(false, \"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://fb.me/react-special-props)\", displayName);\n                            }\n                        };\n                        warnAboutAccessingRef.isReactWarning = true;\n                        Object.defineProperty(props, \"ref\", {\n                            get: warnAboutAccessingRef,\n                            configurable: true\n                        });\n                    }\n                    /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */ var ReactElement = function(type, key, ref, self1, source, owner, props) {\n                        var element = {\n                            // This tag allows us to uniquely identify this as a React Element\n                            $$typeof: REACT_ELEMENT_TYPE,\n                            // Built-in properties that belong on the element\n                            type: type,\n                            key: key,\n                            ref: ref,\n                            props: props,\n                            // Record the component responsible for creating this element.\n                            _owner: owner\n                        };\n                        {\n                            // The validation flag is currently mutative. We put it on\n                            // an external backing store so that we can freeze the whole object.\n                            // This can be replaced with a WeakMap once they are implemented in\n                            // commonly used development environments.\n                            element._store = {};\n                            // To make comparing ReactElements easier for testing purposes, we make\n                            // the validation flag non-enumerable (where possible, which should\n                            // include every environment we run tests in), so the test framework\n                            // ignores it.\n                            Object.defineProperty(element._store, \"validated\", {\n                                configurable: false,\n                                enumerable: false,\n                                writable: true,\n                                value: false\n                            });\n                            // self and source are DEV only properties.\n                            Object.defineProperty(element, \"_self\", {\n                                configurable: false,\n                                enumerable: false,\n                                writable: false,\n                                value: self1\n                            });\n                            // Two elements created in two different places should be considered\n                            // equal for testing purposes and therefore we hide it from enumeration.\n                            Object.defineProperty(element, \"_source\", {\n                                configurable: false,\n                                enumerable: false,\n                                writable: false,\n                                value: source\n                            });\n                            if (Object.freeze) {\n                                Object.freeze(element.props);\n                                Object.freeze(element);\n                            }\n                        }\n                        return element;\n                    };\n                    /**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */ function createElement(type, config, children) {\n                        var propName = void 0;\n                        // Reserved names are extracted\n                        var props = {};\n                        var key = null;\n                        var ref = null;\n                        var self1 = null;\n                        var source = null;\n                        if (config != null) {\n                            if (hasValidRef(config)) {\n                                ref = config.ref;\n                            }\n                            if (hasValidKey(config)) {\n                                key = \"\" + config.key;\n                            }\n                            self1 = config.__self === undefined ? null : config.__self;\n                            source = config.__source === undefined ? null : config.__source;\n                            // Remaining properties are added to a new props object\n                            for(propName in config){\n                                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                                    props[propName] = config[propName];\n                                }\n                            }\n                        }\n                        // Children can be more than one argument, and those are transferred onto\n                        // the newly allocated props object.\n                        var childrenLength = arguments.length - 2;\n                        if (childrenLength === 1) {\n                            props.children = children;\n                        } else if (childrenLength > 1) {\n                            var childArray = Array(childrenLength);\n                            for(var i = 0; i < childrenLength; i++){\n                                childArray[i] = arguments[i + 2];\n                            }\n                            {\n                                if (Object.freeze) {\n                                    Object.freeze(childArray);\n                                }\n                            }\n                            props.children = childArray;\n                        }\n                        // Resolve default props\n                        if (type && type.defaultProps) {\n                            var defaultProps = type.defaultProps;\n                            for(propName in defaultProps){\n                                if (props[propName] === undefined) {\n                                    props[propName] = defaultProps[propName];\n                                }\n                            }\n                        }\n                        {\n                            if (key || ref) {\n                                if (typeof props.$$typeof === \"undefined\" || props.$$typeof !== REACT_ELEMENT_TYPE) {\n                                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                                    if (key) {\n                                        defineKeyPropWarningGetter(props, displayName);\n                                    }\n                                    if (ref) {\n                                        defineRefPropWarningGetter(props, displayName);\n                                    }\n                                }\n                            }\n                        }\n                        return ReactElement(type, key, ref, self1, source, ReactCurrentOwner.current, props);\n                    }\n                    /**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */ function cloneAndReplaceKey(oldElement, newKey) {\n                        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n                        return newElement;\n                    }\n                    /**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */ function cloneElement(element, config, children) {\n                        !!(element === null || element === undefined) ? invariant(false, \"React.cloneElement(...): The argument must be a React element, but you passed %s.\", element) : void 0;\n                        var propName = void 0;\n                        // Original props are copied\n                        var props = _assign({}, element.props);\n                        // Reserved names are extracted\n                        var key = element.key;\n                        var ref = element.ref;\n                        // Self is preserved since the owner is preserved.\n                        var self1 = element._self;\n                        // Source is preserved since cloneElement is unlikely to be targeted by a\n                        // transpiler, and the original source is probably a better indicator of the\n                        // true owner.\n                        var source = element._source;\n                        // Owner will be preserved, unless ref is overridden\n                        var owner = element._owner;\n                        if (config != null) {\n                            if (hasValidRef(config)) {\n                                // Silently steal the ref from the parent.\n                                ref = config.ref;\n                                owner = ReactCurrentOwner.current;\n                            }\n                            if (hasValidKey(config)) {\n                                key = \"\" + config.key;\n                            }\n                            // Remaining properties override existing props\n                            var defaultProps = void 0;\n                            if (element.type && element.type.defaultProps) {\n                                defaultProps = element.type.defaultProps;\n                            }\n                            for(propName in config){\n                                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                                    if (config[propName] === undefined && defaultProps !== undefined) {\n                                        // Resolve default props\n                                        props[propName] = defaultProps[propName];\n                                    } else {\n                                        props[propName] = config[propName];\n                                    }\n                                }\n                            }\n                        }\n                        // Children can be more than one argument, and those are transferred onto\n                        // the newly allocated props object.\n                        var childrenLength = arguments.length - 2;\n                        if (childrenLength === 1) {\n                            props.children = children;\n                        } else if (childrenLength > 1) {\n                            var childArray = Array(childrenLength);\n                            for(var i = 0; i < childrenLength; i++){\n                                childArray[i] = arguments[i + 2];\n                            }\n                            props.children = childArray;\n                        }\n                        return ReactElement(element.type, key, ref, self1, source, owner, props);\n                    }\n                    /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */ function isValidElement(object) {\n                        return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                    }\n                    var ReactDebugCurrentFrame = {};\n                    {\n                        // Component that is being worked on\n                        ReactDebugCurrentFrame.getCurrentStack = null;\n                        ReactDebugCurrentFrame.getStackAddendum = function() {\n                            var impl = ReactDebugCurrentFrame.getCurrentStack;\n                            if (impl) {\n                                return impl();\n                            }\n                            return null;\n                        };\n                    }\n                    var SEPARATOR = \".\";\n                    var SUBSEPARATOR = \":\";\n                    /**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */ function escape(key) {\n                        var escapeRegex = /[=:]/g;\n                        var escaperLookup = {\n                            \"=\": \"=0\",\n                            \":\": \"=2\"\n                        };\n                        var escapedString = (\"\" + key).replace(escapeRegex, function(match) {\n                            return escaperLookup[match];\n                        });\n                        return \"$\" + escapedString;\n                    }\n                    /**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */ var didWarnAboutMaps = false;\n                    var userProvidedKeyEscapeRegex = /\\/+/g;\n                    function escapeUserProvidedKey(text) {\n                        return (\"\" + text).replace(userProvidedKeyEscapeRegex, \"$&/\");\n                    }\n                    var POOL_SIZE = 10;\n                    var traverseContextPool = [];\n                    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n                        if (traverseContextPool.length) {\n                            var traverseContext = traverseContextPool.pop();\n                            traverseContext.result = mapResult;\n                            traverseContext.keyPrefix = keyPrefix;\n                            traverseContext.func = mapFunction;\n                            traverseContext.context = mapContext;\n                            traverseContext.count = 0;\n                            return traverseContext;\n                        } else {\n                            return {\n                                result: mapResult,\n                                keyPrefix: keyPrefix,\n                                func: mapFunction,\n                                context: mapContext,\n                                count: 0\n                            };\n                        }\n                    }\n                    function releaseTraverseContext(traverseContext) {\n                        traverseContext.result = null;\n                        traverseContext.keyPrefix = null;\n                        traverseContext.func = null;\n                        traverseContext.context = null;\n                        traverseContext.count = 0;\n                        if (traverseContextPool.length < POOL_SIZE) {\n                            traverseContextPool.push(traverseContext);\n                        }\n                    }\n                    /**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */ function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n                        var type = typeof children;\n                        if (type === \"undefined\" || type === \"boolean\") {\n                            // All of the above are perceived as null.\n                            children = null;\n                        }\n                        var invokeCallback = false;\n                        if (children === null) {\n                            invokeCallback = true;\n                        } else {\n                            switch(type){\n                                case \"string\":\n                                case \"number\":\n                                    invokeCallback = true;\n                                    break;\n                                case \"object\":\n                                    switch(children.$$typeof){\n                                        case REACT_ELEMENT_TYPE:\n                                        case REACT_PORTAL_TYPE:\n                                            invokeCallback = true;\n                                    }\n                            }\n                        }\n                        if (invokeCallback) {\n                            callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n                            // so that it's consistent if the number of children grows.\n                            nameSoFar === \"\" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n                            return 1;\n                        }\n                        var child = void 0;\n                        var nextName = void 0;\n                        var subtreeCount = 0; // Count of children found in the current subtree.\n                        var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n                        if (Array.isArray(children)) {\n                            for(var i = 0; i < children.length; i++){\n                                child = children[i];\n                                nextName = nextNamePrefix + getComponentKey(child, i);\n                                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n                            }\n                        } else {\n                            var iteratorFn = getIteratorFn(children);\n                            if (typeof iteratorFn === \"function\") {\n                                {\n                                    // Warn about using Maps as children\n                                    if (iteratorFn === children.entries) {\n                                        !didWarnAboutMaps ? warning(false, \"Using Maps as children is unsupported and will likely yield \" + \"unexpected results. Convert it to a sequence/iterable of keyed \" + \"ReactElements instead.%s\", ReactDebugCurrentFrame.getStackAddendum()) : void 0;\n                                        didWarnAboutMaps = true;\n                                    }\n                                }\n                                var iterator = iteratorFn.call(children);\n                                var step = void 0;\n                                var ii = 0;\n                                while(!(step = iterator.next()).done){\n                                    child = step.value;\n                                    nextName = nextNamePrefix + getComponentKey(child, ii++);\n                                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n                                }\n                            } else if (type === \"object\") {\n                                var addendum = \"\";\n                                {\n                                    addendum = \" If you meant to render a collection of children, use an array \" + \"instead.\" + ReactDebugCurrentFrame.getStackAddendum();\n                                }\n                                var childrenString = \"\" + children;\n                                invariant(false, \"Objects are not valid as a React child (found: %s).%s\", childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString, addendum);\n                            }\n                        }\n                        return subtreeCount;\n                    }\n                    /**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */ function traverseAllChildren(children, callback, traverseContext) {\n                        if (children == null) {\n                            return 0;\n                        }\n                        return traverseAllChildrenImpl(children, \"\", callback, traverseContext);\n                    }\n                    /**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */ function getComponentKey(component, index) {\n                        // Do some typechecking here since we call this blindly. We want to ensure\n                        // that we don't block potential future ES APIs.\n                        if (typeof component === \"object\" && component !== null && component.key != null) {\n                            // Explicit key\n                            return escape(component.key);\n                        }\n                        // Implicit key determined by the index in the set\n                        return index.toString(36);\n                    }\n                    function forEachSingleChild(bookKeeping, child, name) {\n                        var func = bookKeeping.func, context = bookKeeping.context;\n                        func.call(context, child, bookKeeping.count++);\n                    }\n                    /**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.foreach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */ function forEachChildren(children, forEachFunc, forEachContext) {\n                        if (children == null) {\n                            return children;\n                        }\n                        var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n                        traverseAllChildren(children, forEachSingleChild, traverseContext);\n                        releaseTraverseContext(traverseContext);\n                    }\n                    function mapSingleChildIntoContext(bookKeeping, child, childKey) {\n                        var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;\n                        var mappedChild = func.call(context, child, bookKeeping.count++);\n                        if (Array.isArray(mappedChild)) {\n                            mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n                        } else if (mappedChild != null) {\n                            if (isValidElement(mappedChild)) {\n                                mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n                                // traverseAllChildren used to do for objects as children\n                                keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + \"/\" : \"\") + childKey);\n                            }\n                            result.push(mappedChild);\n                        }\n                    }\n                    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n                        var escapedPrefix = \"\";\n                        if (prefix != null) {\n                            escapedPrefix = escapeUserProvidedKey(prefix) + \"/\";\n                        }\n                        var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n                        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n                        releaseTraverseContext(traverseContext);\n                    }\n                    /**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.map\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */ function mapChildren(children, func, context) {\n                        if (children == null) {\n                            return children;\n                        }\n                        var result = [];\n                        mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n                        return result;\n                    }\n                    /**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.count\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */ function countChildren(children, context) {\n                        return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n                    }\n                    /**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.toarray\n */ function toArray(children) {\n                        var result = [];\n                        mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n                        return result;\n                    }\n                    /**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.only\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */ function onlyChild(children) {\n                        !isValidElement(children) ? invariant(false, \"React.Children.only expected to receive a single React element child.\") : void 0;\n                        return children;\n                    }\n                    function createContext(defaultValue, calculateChangedBits) {\n                        if (calculateChangedBits === undefined) {\n                            calculateChangedBits = null;\n                        } else {\n                            {\n                                !(calculateChangedBits === null || typeof calculateChangedBits === \"function\") ? warning(false, \"createContext: Expected the optional second argument to be a \" + \"function. Instead received: %s\", calculateChangedBits) : void 0;\n                            }\n                        }\n                        var context = {\n                            $$typeof: REACT_CONTEXT_TYPE,\n                            _calculateChangedBits: calculateChangedBits,\n                            _defaultValue: defaultValue,\n                            _currentValue: defaultValue,\n                            _changedBits: 0,\n                            // These are circular\n                            Provider: null,\n                            Consumer: null\n                        };\n                        context.Provider = {\n                            $$typeof: REACT_PROVIDER_TYPE,\n                            _context: context\n                        };\n                        context.Consumer = context;\n                        {\n                            context._currentRenderer = null;\n                        }\n                        return context;\n                    }\n                    function forwardRef(render) {\n                        {\n                            !(typeof render === \"function\") ? warning(false, \"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render) : void 0;\n                        }\n                        return {\n                            $$typeof: REACT_FORWARD_REF_TYPE,\n                            render: render\n                        };\n                    }\n                    var describeComponentFrame = function(name, source, ownerName) {\n                        return \"\\n    in \" + (name || \"Unknown\") + (source ? \" (at \" + source.fileName.replace(/^.*[\\\\\\/]/, \"\") + \":\" + source.lineNumber + \")\" : ownerName ? \" (created by \" + ownerName + \")\" : \"\");\n                    };\n                    function isValidElementType(type) {\n                        return typeof type === \"string\" || typeof type === \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n                        type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n                    }\n                    function getComponentName(fiber) {\n                        var type = fiber.type;\n                        if (typeof type === \"function\") {\n                            return type.displayName || type.name;\n                        }\n                        if (typeof type === \"string\") {\n                            return type;\n                        }\n                        switch(type){\n                            case REACT_FRAGMENT_TYPE:\n                                return \"ReactFragment\";\n                            case REACT_PORTAL_TYPE:\n                                return \"ReactPortal\";\n                            case REACT_CALL_TYPE:\n                                return \"ReactCall\";\n                            case REACT_RETURN_TYPE:\n                                return \"ReactReturn\";\n                        }\n                        if (typeof type === \"object\" && type !== null) {\n                            switch(type.$$typeof){\n                                case REACT_FORWARD_REF_TYPE:\n                                    var functionName = type.render.displayName || type.render.name || \"\";\n                                    return functionName !== \"\" ? \"ForwardRef(\" + functionName + \")\" : \"ForwardRef\";\n                            }\n                        }\n                        return null;\n                    }\n                    /**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */ var currentlyValidatingElement = void 0;\n                    var propTypesMisspellWarningShown = void 0;\n                    var getDisplayName = function() {};\n                    var getStackAddendum = function() {};\n                    {\n                        currentlyValidatingElement = null;\n                        propTypesMisspellWarningShown = false;\n                        getDisplayName = function(element) {\n                            if (element == null) {\n                                return \"#empty\";\n                            } else if (typeof element === \"string\" || typeof element === \"number\") {\n                                return \"#text\";\n                            } else if (typeof element.type === \"string\") {\n                                return element.type;\n                            } else if (element.type === REACT_FRAGMENT_TYPE) {\n                                return \"React.Fragment\";\n                            } else {\n                                return element.type.displayName || element.type.name || \"Unknown\";\n                            }\n                        };\n                        getStackAddendum = function() {\n                            var stack = \"\";\n                            if (currentlyValidatingElement) {\n                                var name = getDisplayName(currentlyValidatingElement);\n                                var owner = currentlyValidatingElement._owner;\n                                stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n                            }\n                            stack += ReactDebugCurrentFrame.getStackAddendum() || \"\";\n                            return stack;\n                        };\n                    }\n                    function getDeclarationErrorAddendum() {\n                        if (ReactCurrentOwner.current) {\n                            var name = getComponentName(ReactCurrentOwner.current);\n                            if (name) {\n                                return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                            }\n                        }\n                        return \"\";\n                    }\n                    function getSourceInfoErrorAddendum(elementProps) {\n                        if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n                            var source = elementProps.__source;\n                            var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                            var lineNumber = source.lineNumber;\n                            return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                        }\n                        return \"\";\n                    }\n                    /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n                    function getCurrentComponentErrorInfo(parentType) {\n                        var info = getDeclarationErrorAddendum();\n                        if (!info) {\n                            var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n                            if (parentName) {\n                                info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                            }\n                        }\n                        return info;\n                    }\n                    /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n                        if (!element._store || element._store.validated || element.key != null) {\n                            return;\n                        }\n                        element._store.validated = true;\n                        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                            return;\n                        }\n                        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n                        // Usually the current owner is the offender, but if it accepts children as a\n                        // property, it may be the creator of the child that's responsible for\n                        // assigning it a key.\n                        var childOwner = \"\";\n                        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                            // Give the component that originally created this child.\n                            childOwner = \" It was passed a child from \" + getComponentName(element._owner) + \".\";\n                        }\n                        currentlyValidatingElement = element;\n                        {\n                            warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + \"%s%s See https://fb.me/react-warning-keys for more information.%s\", currentComponentErrorInfo, childOwner, getStackAddendum());\n                        }\n                        currentlyValidatingElement = null;\n                    }\n                    /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n                        if (typeof node !== \"object\") {\n                            return;\n                        }\n                        if (Array.isArray(node)) {\n                            for(var i = 0; i < node.length; i++){\n                                var child = node[i];\n                                if (isValidElement(child)) {\n                                    validateExplicitKey(child, parentType);\n                                }\n                            }\n                        } else if (isValidElement(node)) {\n                            // This element was passed in a valid location.\n                            if (node._store) {\n                                node._store.validated = true;\n                            }\n                        } else if (node) {\n                            var iteratorFn = getIteratorFn(node);\n                            if (typeof iteratorFn === \"function\") {\n                                // Entry iterators used to provide implicit keys,\n                                // but now we print a separate warning for them later.\n                                if (iteratorFn !== node.entries) {\n                                    var iterator = iteratorFn.call(node);\n                                    var step = void 0;\n                                    while(!(step = iterator.next()).done){\n                                        if (isValidElement(step.value)) {\n                                            validateExplicitKey(step.value, parentType);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n                        var componentClass = element.type;\n                        if (typeof componentClass !== \"function\") {\n                            return;\n                        }\n                        var name = componentClass.displayName || componentClass.name;\n                        var propTypes = componentClass.propTypes;\n                        if (propTypes) {\n                            currentlyValidatingElement = element;\n                            checkPropTypes(propTypes, element.props, \"prop\", name, getStackAddendum);\n                            currentlyValidatingElement = null;\n                        } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                            propTypesMisspellWarningShown = true;\n                            warning(false, \"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", name || \"Unknown\");\n                        }\n                        if (typeof componentClass.getDefaultProps === \"function\") {\n                            !componentClass.getDefaultProps.isReactClassApproved ? warning(false, \"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\") : void 0;\n                        }\n                    }\n                    /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n                        currentlyValidatingElement = fragment;\n                        var keys = Object.keys(fragment.props);\n                        for(var i = 0; i < keys.length; i++){\n                            var key = keys[i];\n                            if (key !== \"children\" && key !== \"key\") {\n                                warning(false, \"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.%s\", key, getStackAddendum());\n                                break;\n                            }\n                        }\n                        if (fragment.ref !== null) {\n                            warning(false, \"Invalid attribute `ref` supplied to `React.Fragment`.%s\", getStackAddendum());\n                        }\n                        currentlyValidatingElement = null;\n                    }\n                    function createElementWithValidation(type, props, children) {\n                        var validType = isValidElementType(type);\n                        // We warn in this case but don't throw. We expect the element creation to\n                        // succeed and there will likely be errors in render.\n                        if (!validType) {\n                            var info = \"\";\n                            if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                                info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                            }\n                            var sourceInfo = getSourceInfoErrorAddendum(props);\n                            if (sourceInfo) {\n                                info += sourceInfo;\n                            } else {\n                                info += getDeclarationErrorAddendum();\n                            }\n                            info += getStackAddendum() || \"\";\n                            var typeString = void 0;\n                            if (type === null) {\n                                typeString = \"null\";\n                            } else if (Array.isArray(type)) {\n                                typeString = \"array\";\n                            } else {\n                                typeString = typeof type;\n                            }\n                            warning(false, \"React.createElement: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                        }\n                        var element = createElement.apply(this, arguments);\n                        // The result can be nullish if a mock or a custom function is used.\n                        // TODO: Drop this when these are no longer allowed as the type argument.\n                        if (element == null) {\n                            return element;\n                        }\n                        // Skip key warning if the type isn't valid since our key validation logic\n                        // doesn't expect a non-string/function type and can throw confusing errors.\n                        // We don't want exception behavior to differ between dev and prod.\n                        // (Rendering will throw with a helpful message and as soon as the type is\n                        // fixed, the key warnings will appear.)\n                        if (validType) {\n                            for(var i = 2; i < arguments.length; i++){\n                                validateChildKeys(arguments[i], type);\n                            }\n                        }\n                        if (type === REACT_FRAGMENT_TYPE) {\n                            validateFragmentProps(element);\n                        } else {\n                            validatePropTypes(element);\n                        }\n                        return element;\n                    }\n                    function createFactoryWithValidation(type) {\n                        var validatedFactory = createElementWithValidation.bind(null, type);\n                        validatedFactory.type = type;\n                        // Legacy hook: remove it\n                        {\n                            Object.defineProperty(validatedFactory, \"type\", {\n                                enumerable: false,\n                                get: function() {\n                                    lowPriorityWarning$1(false, \"Factory.type is deprecated. Access the class directly \" + \"before passing it to createFactory.\");\n                                    Object.defineProperty(this, \"type\", {\n                                        value: type\n                                    });\n                                    return type;\n                                }\n                            });\n                        }\n                        return validatedFactory;\n                    }\n                    function cloneElementWithValidation(element, props, children) {\n                        var newElement = cloneElement.apply(this, arguments);\n                        for(var i = 2; i < arguments.length; i++){\n                            validateChildKeys(arguments[i], newElement.type);\n                        }\n                        validatePropTypes(newElement);\n                        return newElement;\n                    }\n                    var React = {\n                        Children: {\n                            map: mapChildren,\n                            forEach: forEachChildren,\n                            count: countChildren,\n                            toArray: toArray,\n                            only: onlyChild\n                        },\n                        createRef: createRef,\n                        Component: Component,\n                        PureComponent: PureComponent,\n                        createContext: createContext,\n                        forwardRef: forwardRef,\n                        Fragment: REACT_FRAGMENT_TYPE,\n                        StrictMode: REACT_STRICT_MODE_TYPE,\n                        unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\n                        createElement: createElementWithValidation,\n                        cloneElement: cloneElementWithValidation,\n                        createFactory: createFactoryWithValidation,\n                        isValidElement: isValidElement,\n                        version: ReactVersion,\n                        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n                            ReactCurrentOwner: ReactCurrentOwner,\n                            // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n                            assign: _assign\n                        }\n                    };\n                    {\n                        _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n                            // These should not be included in production.\n                            ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n                            // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n                            // TODO: remove in React 17.0.\n                            ReactComponentTreeHook: {}\n                        });\n                    }\n                    var React$2 = Object.freeze({\n                        default: React\n                    });\n                    var React$3 = React$2 && React || React$2;\n                    // TODO: decide on the top-level export form.\n                    // This is hacky but makes it work with both Rollup and Jest.\n                    var react = React$3[\"default\"] ? React$3[\"default\"] : React$3;\n                    module1.exports = react;\n                })();\n            }\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __nested_webpack_require_105995__) {\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n                var isValidElement = function(object) {\n                    return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                };\n                // By explicitly using `prop-types` you are opting into new development behavior.\n                // http://fb.me/prop-types-in-prod\n                var throwOnDirectAccess = true;\n                module1.exports = __nested_webpack_require_105995__(12)(isValidElement, throwOnDirectAccess);\n            } else {}\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_107173__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var emptyFunction = __nested_webpack_require_107173__(1);\n            var invariant = __nested_webpack_require_107173__(0);\n            var warning = __nested_webpack_require_107173__(3);\n            var assign = __nested_webpack_require_107173__(2);\n            var ReactPropTypesSecret = __nested_webpack_require_107173__(4);\n            var checkPropTypes = __nested_webpack_require_107173__(6);\n            module1.exports = function(isValidElement, throwOnDirectAccess) {\n                /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */ function getIteratorFn(maybeIterable) {\n                    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                    if (typeof iteratorFn === \"function\") {\n                        return iteratorFn;\n                    }\n                }\n                /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */ var ANONYMOUS = \"<<anonymous>>\";\n                // Important!\n                // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                var ReactPropTypes = {\n                    array: createPrimitiveTypeChecker(\"array\"),\n                    bool: createPrimitiveTypeChecker(\"boolean\"),\n                    func: createPrimitiveTypeChecker(\"function\"),\n                    number: createPrimitiveTypeChecker(\"number\"),\n                    object: createPrimitiveTypeChecker(\"object\"),\n                    string: createPrimitiveTypeChecker(\"string\"),\n                    symbol: createPrimitiveTypeChecker(\"symbol\"),\n                    any: createAnyTypeChecker(),\n                    arrayOf: createArrayOfTypeChecker,\n                    element: createElementTypeChecker(),\n                    instanceOf: createInstanceTypeChecker,\n                    node: createNodeChecker(),\n                    objectOf: createObjectOfTypeChecker,\n                    oneOf: createEnumTypeChecker,\n                    oneOfType: createUnionTypeChecker,\n                    shape: createShapeTypeChecker,\n                    exact: createStrictShapeTypeChecker\n                };\n                /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                    // SameValue algorithm\n                    if (x === y) {\n                        // Steps 1-5, 7-10\n                        // Steps 6.b-6.e: +0 != -0\n                        return x !== 0 || 1 / x === 1 / y;\n                    } else {\n                        // Step 6.a: NaN == NaN\n                        return x !== x && y !== y;\n                    }\n                }\n                /*eslint-enable no-self-compare*/ /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */ function PropTypeError(message) {\n                    this.message = message;\n                    this.stack = \"\";\n                }\n                // Make `instanceof Error` still work for returned errors.\n                PropTypeError.prototype = Error.prototype;\n                function createChainableTypeChecker(validate) {\n                    if (true) {\n                        var manualPropTypeCallCache = {};\n                        var manualPropTypeWarningCount = 0;\n                    }\n                    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                        componentName = componentName || ANONYMOUS;\n                        propFullName = propFullName || propName;\n                        if (secret !== ReactPropTypesSecret) {\n                            if (throwOnDirectAccess) {\n                                // New behavior only for users of `prop-types` package\n                                invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                            } else if ( true && typeof console !== \"undefined\") {\n                                // Old behavior for people using React.PropTypes\n                                var cacheKey = componentName + \":\" + propName;\n                                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                manualPropTypeWarningCount < 3) {\n                                    warning(false, \"You are manually calling a React.PropTypes validation \" + \"function for the `%s` prop on `%s`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\", propFullName, componentName);\n                                    manualPropTypeCallCache[cacheKey] = true;\n                                    manualPropTypeWarningCount++;\n                                }\n                            }\n                        }\n                        if (props[propName] == null) {\n                            if (isRequired) {\n                                if (props[propName] === null) {\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                }\n                                return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                            }\n                            return null;\n                        } else {\n                            return validate(props, propName, componentName, location, propFullName);\n                        }\n                    }\n                    var chainedCheckType = checkType.bind(null, false);\n                    chainedCheckType.isRequired = checkType.bind(null, true);\n                    return chainedCheckType;\n                }\n                function createPrimitiveTypeChecker(expectedType) {\n                    function validate(props, propName, componentName, location, propFullName, secret) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== expectedType) {\n                            // `propValue` being instance of, say, date/regexp, pass the 'object'\n                            // check, but we can offer a more precise error message here rather than\n                            // 'of type `object`'.\n                            var preciseType = getPreciseType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createAnyTypeChecker() {\n                    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n                }\n                function createArrayOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                        }\n                        var propValue = props[propName];\n                        if (!Array.isArray(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                        }\n                        for(var i = 0; i < propValue.length; i++){\n                            var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                            if (error instanceof Error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createElementTypeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        if (!isValidElement(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createInstanceTypeChecker(expectedClass) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!(props[propName] instanceof expectedClass)) {\n                            var expectedClassName = expectedClass.name || ANONYMOUS;\n                            var actualClassName = getClassName(props[propName]);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createEnumTypeChecker(expectedValues) {\n                    if (!Array.isArray(expectedValues)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOf, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        for(var i = 0; i < expectedValues.length; i++){\n                            if (is(propValue, expectedValues[i])) {\n                                return null;\n                            }\n                        }\n                        var valuesString = JSON.stringify(expectedValues);\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + propValue + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createObjectOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                        }\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                        }\n                        for(var key in propValue){\n                            if (propValue.hasOwnProperty(key)) {\n                                var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createUnionTypeChecker(arrayOfTypeCheckers) {\n                    if (!Array.isArray(arrayOfTypeCheckers)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                        var checker = arrayOfTypeCheckers[i];\n                        if (typeof checker !== \"function\") {\n                            warning(false, \"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received %s at index %s.\", getPostfixForTypeWarning(checker), i);\n                            return emptyFunction.thatReturnsNull;\n                        }\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n                                return null;\n                            }\n                        }\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`.\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createNodeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!isNode(props[propName])) {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        for(var key in shapeTypes){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                continue;\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createStrictShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        // We need to check all keys in case some are required but missing from\n                        // props.\n                        var allKeys = assign({}, props[propName], shapeTypes);\n                        for(var key in allKeys){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function isNode(propValue) {\n                    switch(typeof propValue){\n                        case \"number\":\n                        case \"string\":\n                        case \"undefined\":\n                            return true;\n                        case \"boolean\":\n                            return !propValue;\n                        case \"object\":\n                            if (Array.isArray(propValue)) {\n                                return propValue.every(isNode);\n                            }\n                            if (propValue === null || isValidElement(propValue)) {\n                                return true;\n                            }\n                            var iteratorFn = getIteratorFn(propValue);\n                            if (iteratorFn) {\n                                var iterator = iteratorFn.call(propValue);\n                                var step;\n                                if (iteratorFn !== propValue.entries) {\n                                    while(!(step = iterator.next()).done){\n                                        if (!isNode(step.value)) {\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    // Iterator will provide entry [k,v] tuples rather than values.\n                                    while(!(step = iterator.next()).done){\n                                        var entry = step.value;\n                                        if (entry) {\n                                            if (!isNode(entry[1])) {\n                                                return false;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                return false;\n                            }\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n                function isSymbol(propType, propValue) {\n                    // Native Symbol.\n                    if (propType === \"symbol\") {\n                        return true;\n                    }\n                    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                        return true;\n                    }\n                    // Fallback for non-spec compliant Symbols which are polyfilled.\n                    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                        return true;\n                    }\n                    return false;\n                }\n                // Equivalent of `typeof` but with special handling for array and regexp.\n                function getPropType(propValue) {\n                    var propType = typeof propValue;\n                    if (Array.isArray(propValue)) {\n                        return \"array\";\n                    }\n                    if (propValue instanceof RegExp) {\n                        // Old webkits (at least until Android 4.0) return 'function' rather than\n                        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                        // passes PropTypes.object.\n                        return \"object\";\n                    }\n                    if (isSymbol(propType, propValue)) {\n                        return \"symbol\";\n                    }\n                    return propType;\n                }\n                // This handles more types than `getPropType`. Only used for error messages.\n                // See `createPrimitiveTypeChecker`.\n                function getPreciseType(propValue) {\n                    if (typeof propValue === \"undefined\" || propValue === null) {\n                        return \"\" + propValue;\n                    }\n                    var propType = getPropType(propValue);\n                    if (propType === \"object\") {\n                        if (propValue instanceof Date) {\n                            return \"date\";\n                        } else if (propValue instanceof RegExp) {\n                            return \"regexp\";\n                        }\n                    }\n                    return propType;\n                }\n                // Returns a string that is postfixed to a warning about an invalid type.\n                // For example, \"undefined\" or \"of type array\"\n                function getPostfixForTypeWarning(value) {\n                    var type = getPreciseType(value);\n                    switch(type){\n                        case \"array\":\n                        case \"object\":\n                            return \"an \" + type;\n                        case \"boolean\":\n                        case \"date\":\n                        case \"regexp\":\n                            return \"a \" + type;\n                        default:\n                            return type;\n                    }\n                }\n                // Returns class name of the object, if any.\n                function getClassName(propValue) {\n                    if (!propValue.constructor || !propValue.constructor.name) {\n                        return ANONYMOUS;\n                    }\n                    return propValue.constructor.name;\n                }\n                ReactPropTypes.checkPropTypes = checkPropTypes;\n                ReactPropTypes.PropTypes = ReactPropTypes;\n                return ReactPropTypes;\n            };\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __nested_webpack_require_133513__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var emptyFunction = __nested_webpack_require_133513__(1);\n            var invariant = __nested_webpack_require_133513__(0);\n            var ReactPropTypesSecret = __nested_webpack_require_133513__(4);\n            module1.exports = function() {\n                function shim(props, propName, componentName, location, propFullName, secret) {\n                    if (secret === ReactPropTypesSecret) {\n                        // It is still safe when called from React.\n                        return;\n                    }\n                    invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use PropTypes.checkPropTypes() to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                }\n                ;\n                shim.isRequired = shim;\n                function getShim() {\n                    return shim;\n                }\n                ;\n                // Important!\n                // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n                var ReactPropTypes = {\n                    array: shim,\n                    bool: shim,\n                    func: shim,\n                    number: shim,\n                    object: shim,\n                    string: shim,\n                    symbol: shim,\n                    any: shim,\n                    arrayOf: getShim,\n                    element: shim,\n                    instanceOf: getShim,\n                    node: shim,\n                    objectOf: getShim,\n                    oneOf: getShim,\n                    oneOfType: getShim,\n                    shape: getShim,\n                    exact: getShim\n                };\n                ReactPropTypes.checkPropTypes = emptyFunction;\n                ReactPropTypes.PropTypes = ReactPropTypes;\n                return ReactPropTypes;\n            };\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __nested_webpack_require_135674__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _blank = __nested_webpack_require_135674__(15);\n            Object.defineProperty(exports1, \"blank\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_blank).default;\n                }\n            });\n            var _loadingBalls = __nested_webpack_require_135674__(16);\n            Object.defineProperty(exports1, \"balls\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingBalls).default;\n                }\n            });\n            var _loadingBars = __nested_webpack_require_135674__(17);\n            Object.defineProperty(exports1, \"bars\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingBars).default;\n                }\n            });\n            var _loadingBubbles = __nested_webpack_require_135674__(18);\n            Object.defineProperty(exports1, \"bubbles\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingBubbles).default;\n                }\n            });\n            var _loadingCubes = __nested_webpack_require_135674__(19);\n            Object.defineProperty(exports1, \"cubes\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingCubes).default;\n                }\n            });\n            var _loadingCylon = __nested_webpack_require_135674__(20);\n            Object.defineProperty(exports1, \"cylon\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingCylon).default;\n                }\n            });\n            var _loadingSpin = __nested_webpack_require_135674__(21);\n            Object.defineProperty(exports1, \"spin\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingSpin).default;\n                }\n            });\n            var _loadingSpinningBubbles = __nested_webpack_require_135674__(22);\n            Object.defineProperty(exports1, \"spinningBubbles\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingSpinningBubbles).default;\n                }\n            });\n            var _loadingSpokes = __nested_webpack_require_135674__(23);\n            Object.defineProperty(exports1, \"spokes\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingSpokes).default;\n                }\n            });\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"icon-blank\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\"></svg>\\n';\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"icon-loading\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path transform=\"translate(-8 0)\" d=\"M4 12 A4 4 0 0 0 4 20 A4 4 0 0 0 4 12\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"-8 0; 2 0; 2 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.25;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(2 0)\" d=\"M4 12 A4 4 0 0 0 4 20 A4 4 0 0 0 4 12\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"2 0; 12 0; 12 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.35;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(12 0)\" d=\"M4 12 A4 4 0 0 0 4 20 A4 4 0 0 0 4 12\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"12 0; 22 0; 22 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.45;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(24 0)\" d=\"M4 12 A4 4 0 0 0 4 20 A4 4 0 0 0 4 12\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"22 0; 32 0; 32 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.55;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path transform=\"translate(2)\" d=\"M0 12 V20 H4 V12z\"> \\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(8)\" d=\"M0 12 V20 H4 V12z\">\\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.2\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(14)\" d=\"M0 12 V20 H4 V12z\">\\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.4\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n  <path transform=\"translate(20)\" d=\"M0 12 V20 H4 V12z\">\\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.6\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n  <path transform=\"translate(26)\" d=\"M0 12 V20 H4 V12z\">\\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.8\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <circle transform=\"translate(8 0)\" cx=\"0\" cy=\"16\" r=\"0\"> \\n    <animate attributeName=\"r\" values=\"0; 4; 0; 0\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0\"\\n      keytimes=\"0;0.2;0.7;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"translate(16 0)\" cx=\"0\" cy=\"16\" r=\"0\"> \\n    <animate attributeName=\"r\" values=\"0; 4; 0; 0\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.3\"\\n      keytimes=\"0;0.2;0.7;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"translate(24 0)\" cx=\"0\" cy=\"16\" r=\"0\"> \\n    <animate attributeName=\"r\" values=\"0; 4; 0; 0\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.6\"\\n      keytimes=\"0;0.2;0.7;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n</svg>\\n';\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path transform=\"translate(-8 0)\" d=\"M0 12 V20 H8 V12z\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"-8 0; 2 0; 2 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.25;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(2 0)\" d=\"M0 12 V20 H8 V12z\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"2 0; 12 0; 12 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.35;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(12 0)\" d=\"M0 12 V20 H8 V12z\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"12 0; 22 0; 22 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.45;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(24 0)\" d=\"M0 12 V20 H8 V12z\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"22 0; 32 0; 32 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.55;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path transform=\"translate(0 0)\" d=\"M0 12 V20 H4 V12z\">\\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"0 0; 28 0; 0 0; 0 0\" dur=\"1.5s\" begin=\"0\" repeatCount=\"indefinite\" keytimes=\"0;0.3;0.6;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n  <path opacity=\"0.5\" transform=\"translate(0 0)\" d=\"M0 12 V20 H4 V12z\">\\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"0 0; 28 0; 0 0; 0 0\" dur=\"1.5s\" begin=\"0.1s\" repeatCount=\"indefinite\" keytimes=\"0;0.3;0.6;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n  <path opacity=\"0.25\" transform=\"translate(0 0)\" d=\"M0 12 V20 H4 V12z\">\\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"0 0; 28 0; 0 0; 0 0\" dur=\"1.5s\" begin=\"0.2s\" repeatCount=\"indefinite\" keytimes=\"0;0.3;0.6;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path opacity=\".25\" d=\"M16 0 A16 16 0 0 0 16 32 A16 16 0 0 0 16 0 M16 4 A12 12 0 0 1 16 28 A12 12 0 0 1 16 4\"/>\\n  <path d=\"M16 0 A16 16 0 0 1 32 16 L28 16 A12 12 0 0 0 16 4z\">\\n    <animateTransform attributeName=\"transform\" type=\"rotate\" from=\"0 16 16\" to=\"360 16 16\" dur=\"0.8s\" repeatCount=\"indefinite\" />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <circle cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(45 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.125s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(90 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.25s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(135 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.375s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(180 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.5s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(225 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.625s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(270 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.75s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(315 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.875s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(180 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.5s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n</svg>\\n';\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg id=\"loading\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(0 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(45 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.125s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(90 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.25s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(135 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.375s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(180 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.5s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(225 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.675s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(270 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.75s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(315 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.875s\"/>\\n  </path>\\n</svg>\\n';\n        /***/ }\n    ]);\n}); //# sourceMappingURL=react-loading.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbG9hZGluZy9kaXN0L3JlYWN0LWxvYWRpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUMsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRDtTQUNiLEVBS3dCQTtBQUM5QixHQUFHLE9BQU9LLFNBQVMsY0FBY0EsT0FBTyxJQUFJLEVBQUU7SUFDOUMsT0FBZ0IsTUFBSCxHQUFJLFNBQVNDLE9BQU87UUFDakMsTUFBTSxHQUFJLG1CQUFtQjtRQUM3QixNQUFNLEdBQUksSUFBSUMsbUJBQW1CLENBQUM7UUFDbEMsTUFBTSxHQUNOLE1BQU0sR0FBSSx1QkFBdUI7UUFDakMsTUFBTSxHQUFJLFNBQVNDLDhCQUFtQkEsQ0FBQ0MsUUFBUTtZQUMvQyxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUssSUFBR0YsZ0JBQWdCLENBQUNFLFNBQVMsRUFBRTtnQkFDMUMsTUFBTSxHQUFNLE9BQU9GLGdCQUFnQixDQUFDRSxTQUFTLENBQUNSLE9BQU87WUFDckQsTUFBTSxHQUFLO1lBQ1gsTUFBTSxHQUFLLGtEQUFrRDtZQUM3RCxNQUFNLEdBQUssSUFBSUMsVUFBU0ssZ0JBQWdCLENBQUNFLFNBQVMsR0FBRztnQkFDckQsTUFBTSxHQUFNQyxHQUFHRDtnQkFDZixNQUFNLEdBQU1FLEdBQUc7Z0JBQ2YsTUFBTSxHQUFNVixTQUFTLENBQUM7WUFDWDtZQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS0ssT0FBTyxDQUFDRyxTQUFTLENBQUNHLElBQUksQ0FBQ1YsUUFBT0QsT0FBTyxFQUFFQyxTQUFRQSxRQUFPRCxPQUFPLEVBQUVPLDhCQUFtQkE7WUFDN0YsTUFBTSxHQUNOLE1BQU0sR0FBSyw0QkFBNEI7WUFDdkMsTUFBTSxHQUFLTixRQUFPUyxDQUFDLEdBQUc7WUFDdEIsTUFBTSxHQUNOLE1BQU0s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LEdBQUksU0FBU0MsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUc7UUFFakIsR0FBRyxHQUFHO1FBQ04sTUFBTSxHQUNOLEdBQUcsR0FBSSxTQUFTQyxPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBRztRQUVqQixHQUFHLEdBQUc7UUFDTixNQUFNLEdBQ04sR0FBRyxHQUFJLFNBQVNDLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHO1FBRWpCLEdBQUcsR0FBRztRQUNOLE1BQU0sR0FDTixHQUFHLEdBQUksU0FBU0MsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUc7UUFFakIsR0FBRyxHQUFHO0tBQ0k7QUFDVixJQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3NvbGFuYV93YWxsZXRfdHJhY2tlci8uL25vZGVfbW9kdWxlcy9yZWFjdC1sb2FkaW5nL2Rpc3QvcmVhY3QtbG9hZGluZy5qcz81YzA1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkxvYWRpbmdcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiTG9hZGluZ1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDcpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuXG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuICB2YXIgd2FybmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX3N2ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgc3ZnU291cmNlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9zdmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIExvYWRpbmcgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTG9hZGluZywgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTG9hZGluZygpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZGluZyk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gTG9hZGluZy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExvYWRpbmcpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRlbGF5ZWQ6IF90aGlzLnByb3BzLmRlbGF5ID4gMFxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExvYWRpbmcsIFt7XG4gICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVsYXkgPSB0aGlzLnByb3BzLmRlbGF5O1xuICAgICAgdmFyIGRlbGF5ZWQgPSB0aGlzLnN0YXRlLmRlbGF5ZWQ7XG5cblxuICAgICAgaWYgKGRlbGF5ZWQpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRlbGF5ZWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG5cblxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbG9yID0gX3Byb3BzLmNvbG9yLFxuICAgICAgICAgIGRlbGF5ID0gX3Byb3BzLmRlbGF5LFxuICAgICAgICAgIHR5cGUgPSBfcHJvcHMudHlwZSxcbiAgICAgICAgICBoZWlnaHQgPSBfcHJvcHMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX3Byb3BzLndpZHRoLFxuICAgICAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnY29sb3InLCAnZGVsYXknLCAndHlwZScsICdoZWlnaHQnLCAnd2lkdGgnXSk7XG5cbiAgICAgIHZhciBzZWxlY3RlZFR5cGUgPSB0aGlzLnN0YXRlLmRlbGF5ZWQgPyAnYmxhbmsnIDogdHlwZTtcbiAgICAgIHZhciBzdmcgPSBzdmdTb3VyY2VzW3NlbGVjdGVkVHlwZV07XG4gICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIF9leHRlbmRzKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IHN2ZyB9XG4gICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTG9hZGluZztcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbkxvYWRpbmcucHJvcFR5cGVzID0ge1xuICBjb2xvcjogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGRlbGF5OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgdHlwZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGhlaWdodDogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcl0pLFxuICB3aWR0aDogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcl0pXG59O1xuTG9hZGluZy5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbG9yOiAnI2ZmZicsXG4gIGRlbGF5OiAwLFxuICB0eXBlOiAnYmFsbHMnLFxuICBoZWlnaHQ6IDY0LFxuICB3aWR0aDogNjRcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBMb2FkaW5nO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjMuMlxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgbT1fX3dlYnBhY2tfcmVxdWlyZV9fKDIpLG49X193ZWJwYWNrX3JlcXVpcmVfXygwKSxwPV9fd2VicGFja19yZXF1aXJlX18oNSkscT1fX3dlYnBhY2tfcmVxdWlyZV9fKDEpLHI9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sW1wiZm9yXCJdLHQ9cj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLHU9cj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsdj1yP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LHc9cj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTo2MDEwOCx4PXI/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucHJvdmlkZXJcIik6NjAxMDkseT1yP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNvbnRleHRcIik6NjAxMTAsej1yP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmFzeW5jX21vZGVcIik6NjAxMTEsQT1yP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmZvcndhcmRfcmVmXCIpOlxuNjAxMTIsQj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7ZnVuY3Rpb24gQyhhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGU9XCJodHRwOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGM9MDtjPGI7YysrKWUrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYysxXSk7bighMSxcIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCAlcyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuIFwiLGUpfXZhciBEPXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fTtcbmZ1bmN0aW9uIEUoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9cDt0aGlzLnVwZGF0ZXI9ZXx8RH1FLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O0UucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YT9DKFwiODVcIik6dm9pZCAwO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKX07RS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGEsXCJmb3JjZVVwZGF0ZVwiKX07ZnVuY3Rpb24gRigpe31GLnByb3RvdHlwZT1FLnByb3RvdHlwZTtmdW5jdGlvbiBHKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPXA7dGhpcy51cGRhdGVyPWV8fER9dmFyIEg9Ry5wcm90b3R5cGU9bmV3IEY7XG5ILmNvbnN0cnVjdG9yPUc7bShILEUucHJvdG90eXBlKTtILmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwO3ZhciBJPXtjdXJyZW50Om51bGx9LEo9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxLPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07XG5mdW5jdGlvbiBMKGEsYixlKXt2YXIgYz12b2lkIDAsZD17fSxnPW51bGwsaD1udWxsO2lmKG51bGwhPWIpZm9yKGMgaW4gdm9pZCAwIT09Yi5yZWYmJihoPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGc9XCJcIitiLmtleSksYilKLmNhbGwoYixjKSYmIUsuaGFzT3duUHJvcGVydHkoYykmJihkW2NdPWJbY10pO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZilkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2Zvcih2YXIgaz1BcnJheShmKSxsPTA7bDxmO2wrKylrW2xdPWFyZ3VtZW50c1tsKzJdO2QuY2hpbGRyZW49a31pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoYyBpbiBmPWEuZGVmYXVsdFByb3BzLGYpdm9pZCAwPT09ZFtjXSYmKGRbY109ZltjXSk7cmV0dXJueyQkdHlwZW9mOnQsdHlwZTphLGtleTpnLHJlZjpoLHByb3BzOmQsX293bmVyOkkuY3VycmVudH19XG5mdW5jdGlvbiBNKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT10fWZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCJcXHgzZFwiOlwiXFx4M2QwXCIsXCI6XCI6XCJcXHgzZDJcIn07cmV0dXJuXCIkXCIrKFwiXCIrYSkucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfSl9dmFyIE49L1xcLysvZyxPPVtdO2Z1bmN0aW9uIFAoYSxiLGUsYyl7aWYoTy5sZW5ndGgpe3ZhciBkPU8ucG9wKCk7ZC5yZXN1bHQ9YTtkLmtleVByZWZpeD1iO2QuZnVuYz1lO2QuY29udGV4dD1jO2QuY291bnQ9MDtyZXR1cm4gZH1yZXR1cm57cmVzdWx0OmEsa2V5UHJlZml4OmIsZnVuYzplLGNvbnRleHQ6Yyxjb3VudDowfX1mdW5jdGlvbiBRKGEpe2EucmVzdWx0PW51bGw7YS5rZXlQcmVmaXg9bnVsbDthLmZ1bmM9bnVsbDthLmNvbnRleHQ9bnVsbDthLmNvdW50PTA7MTA+Ty5sZW5ndGgmJk8ucHVzaChhKX1cbmZ1bmN0aW9uIFIoYSxiLGUsYyl7dmFyIGQ9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWR8fFwiYm9vbGVhblwiPT09ZClhPW51bGw7dmFyIGc9ITE7aWYobnVsbD09PWEpZz0hMDtlbHNlIHN3aXRjaChkKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmc9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHQ6Y2FzZSB1Omc9ITB9fWlmKGcpcmV0dXJuIGUoYyxhLFwiXCI9PT1iP1wiLlwiK1MoYSwwKTpiKSwxO2c9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGg9MDtoPGEubGVuZ3RoO2grKyl7ZD1hW2hdO3ZhciBmPWIrUyhkLGgpO2crPVIoZCxmLGUsYyl9ZWxzZSBpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP2Y9bnVsbDooZj1CJiZhW0JdfHxhW1wiQEBpdGVyYXRvclwiXSxmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmP2Y6bnVsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLFxuaD0wOyEoZD1hLm5leHQoKSkuZG9uZTspZD1kLnZhbHVlLGY9YitTKGQsaCsrKSxnKz1SKGQsZixlLGMpO2Vsc2VcIm9iamVjdFwiPT09ZCYmKGU9XCJcIithLEMoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1lP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmUsXCJcIikpO3JldHVybiBnfWZ1bmN0aW9uIFMoYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoYS5rZXkpOmIudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIFQoYSxiKXthLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspfVxuZnVuY3Rpb24gVShhLGIsZSl7dmFyIGM9YS5yZXN1bHQsZD1hLmtleVByZWZpeDthPWEuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyk7QXJyYXkuaXNBcnJheShhKT9WKGEsYyxlLHEudGhhdFJldHVybnNBcmd1bWVudCk6bnVsbCE9YSYmKE0oYSkmJihiPWQrKCFhLmtleXx8YiYmYi5rZXk9PT1hLmtleT9cIlwiOihcIlwiK2Eua2V5KS5yZXBsYWNlKE4sXCIkXFx4MjYvXCIpK1wiL1wiKStlLGE9eyQkdHlwZW9mOnQsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfSksYy5wdXNoKGEpKX1mdW5jdGlvbiBWKGEsYixlLGMsZCl7dmFyIGc9XCJcIjtudWxsIT1lJiYoZz0oXCJcIitlKS5yZXBsYWNlKE4sXCIkXFx4MjYvXCIpK1wiL1wiKTtiPVAoYixnLGMsZCk7bnVsbD09YXx8UihhLFwiXCIsVSxiKTtRKGIpfVxudmFyIFc9e0NoaWxkcmVuOnttYXA6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGM9W107VihhLGMsbnVsbCxiLGUpO3JldHVybiBjfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO2I9UChudWxsLG51bGwsYixlKTtudWxsPT1hfHxSKGEsXCJcIixULGIpO1EoYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hPzA6UihhLFwiXCIscS50aGF0UmV0dXJuc051bGwsbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107VihhLGIsbnVsbCxxLnRoYXRSZXR1cm5zQXJndW1lbnQpO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe00oYSk/dm9pZCAwOkMoXCIxNDNcIik7cmV0dXJuIGF9fSxjcmVhdGVSZWY6ZnVuY3Rpb24oKXtyZXR1cm57Y3VycmVudDpudWxsfX0sQ29tcG9uZW50OkUsUHVyZUNvbXBvbmVudDpHLGNyZWF0ZUNvbnRleHQ6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjp5LFxuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOmIsX2RlZmF1bHRWYWx1ZTphLF9jdXJyZW50VmFsdWU6YSxfY2hhbmdlZEJpdHM6MCxQcm92aWRlcjpudWxsLENvbnN1bWVyOm51bGx9O2EuUHJvdmlkZXI9eyQkdHlwZW9mOngsX2NvbnRleHQ6YX07cmV0dXJuIGEuQ29uc3VtZXI9YX0sZm9yd2FyZFJlZjpmdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6QSxyZW5kZXI6YX19LEZyYWdtZW50OnYsU3RyaWN0TW9kZTp3LHVuc3RhYmxlX0FzeW5jTW9kZTp6LGNyZWF0ZUVsZW1lbnQ6TCxjbG9uZUVsZW1lbnQ6ZnVuY3Rpb24oYSxiLGUpe251bGw9PT1hfHx2b2lkIDA9PT1hP0MoXCIyNjdcIixhKTp2b2lkIDA7dmFyIGM9dm9pZCAwLGQ9bSh7fSxhLnByb3BzKSxnPWEua2V5LGg9YS5yZWYsZj1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGg9Yi5yZWYsZj1JLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZz1cIlwiK2Iua2V5KTt2YXIgaz12b2lkIDA7YS50eXBlJiZhLnR5cGUuZGVmYXVsdFByb3BzJiZcbihrPWEudHlwZS5kZWZhdWx0UHJvcHMpO2ZvcihjIGluIGIpSi5jYWxsKGIsYykmJiFLLmhhc093blByb3BlcnR5KGMpJiYoZFtjXT12b2lkIDA9PT1iW2NdJiZ2b2lkIDAhPT1rP2tbY106YltjXSl9Yz1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWMpZC5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxjKXtrPUFycmF5KGMpO2Zvcih2YXIgbD0wO2w8YztsKyspa1tsXT1hcmd1bWVudHNbbCsyXTtkLmNoaWxkcmVuPWt9cmV0dXJueyQkdHlwZW9mOnQsdHlwZTphLnR5cGUsa2V5OmcscmVmOmgscHJvcHM6ZCxfb3duZXI6Zn19LGNyZWF0ZUZhY3Rvcnk6ZnVuY3Rpb24oYSl7dmFyIGI9TC5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9LGlzVmFsaWRFbGVtZW50Ok0sdmVyc2lvbjpcIjE2LjMuMlwiLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntSZWFjdEN1cnJlbnRPd25lcjpJLGFzc2lnbjptfX0sWD1PYmplY3QuZnJlZXplKHtkZWZhdWx0Old9KSxcblk9WCYmV3x8WDttb2R1bGUuZXhwb3J0cz1ZW1wiZGVmYXVsdFwiXT9ZW1wiZGVmYXVsdFwiXTpZO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjMuMlxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBlbXB0eU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgd2FybmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4zLjInO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gaGF2ZSBwcmVzZXJ2ZSB0aGUgZm9ybWF0IGFuZCBwYXJhbXMgaW4gdGhlIHd3dyBidWlsZHMuXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkICVzLicsIGVsZW1lbnQpIDogdm9pZCAwO1xuXG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZvaWQgMDtcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMDtcbiAgdmFyIG5leHROYW1lID0gdm9pZCAwO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG51bGwsIG51bGwsIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgICEoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IG51bGwgfHwgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmcoZmFsc2UsICdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2NoYW5nZWRCaXRzOiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG5cbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICBjb250ZXh0LkNvbnN1bWVyID0gY29udGV4dDtcblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgISh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmcoZmFsc2UsICdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcikgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdENhbGwnO1xuICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0UmV0dXJuJztcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbnZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IHZvaWQgMDtcbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHZvaWQgMDtcblxudmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKCkge307XG52YXIgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcblxuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuXG4gIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7XG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lcikpO1xuICAgIH1cbiAgICBzdGFjayArPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50UHJvcHMuX19zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50UHJvcHMuX19zb3VyY2U7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICdcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyKSArICcuJztcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgdmFyIHByb3BUeXBlcyA9IGNvbXBvbmVudENsYXNzLnByb3BUeXBlcztcbiAgaWYgKHByb3BUeXBlcykge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudENsYXNzLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgbmFtZSB8fCAnVW5rbm93bicpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA/IHdhcm5pbmcoZmFsc2UsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBmcmFnbWVudDtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLiVzJywga2V5LCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiVzJywgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpO1xuXG4gIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHByb3BzKTtcbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIGluZm8gKz0gZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuXG4gICAgdmFyIHR5cGVTdHJpbmcgPSB2b2lkIDA7XG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcbiAgLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuICBDaGlsZHJlbjoge1xuICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgY3JlYXRlUmVmOiBjcmVhdGVSZWYsXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXG4gIGZvcndhcmRSZWY6IGZvcndhcmRSZWYsXG5cbiAgRnJhZ21lbnQ6IFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG4gIFN0cmljdE1vZGU6IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUsXG4gIHVuc3RhYmxlX0FzeW5jTW9kZTogUkVBQ1RfQVNZTkNfTU9ERV9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSgpO1xufVxuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxudmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYmxhbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdibGFuaycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JsYW5rKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9sb2FkaW5nQmFsbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdiYWxscycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvYWRpbmdCYWxscykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfbG9hZGluZ0JhcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdiYXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9hZGluZ0JhcnMpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2xvYWRpbmdCdWJibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYnViYmxlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvYWRpbmdCdWJibGVzKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9sb2FkaW5nQ3ViZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjdWJlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvYWRpbmdDdWJlcykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfbG9hZGluZ0N5bG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY3lsb24nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkaW5nQ3lsb24pLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2xvYWRpbmdTcGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc3BpbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvYWRpbmdTcGluKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9sb2FkaW5nU3Bpbm5pbmdCdWJibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc3Bpbm5pbmdCdWJibGVzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9hZGluZ1NwaW5uaW5nQnViYmxlcykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfbG9hZGluZ1Nwb2tlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3Nwb2tlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvYWRpbmdTcG9rZXMpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGNsYXNzPVxcXCJpY29uLWJsYW5rXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+PC9zdmc+XFxuXCJcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBjbGFzcz1cXFwiaWNvbi1sb2FkaW5nXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+XFxuICA8cGF0aCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtOCAwKVxcXCIgZD1cXFwiTTQgMTIgQTQgNCAwIDAgMCA0IDIwIEE0IDQgMCAwIDAgNCAxMlxcXCI+IFxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCItOCAwOyAyIDA7IDIgMDtcXFwiIGR1cj1cXFwiMC44c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwXFxcIiBrZXl0aW1lcz1cXFwiMDsuMjU7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgIC8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyIDApXFxcIiBkPVxcXCJNNCAxMiBBNCA0IDAgMCAwIDQgMjAgQTQgNCAwIDAgMCA0IDEyXFxcIj4gXFxuICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9XFxcInRyYW5zZm9ybVxcXCIgdHlwZT1cXFwidHJhbnNsYXRlXFxcIiB2YWx1ZXM9XFxcIjIgMDsgMTIgMDsgMTIgMDtcXFwiIGR1cj1cXFwiMC44c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwXFxcIiBrZXl0aW1lcz1cXFwiMDsuMzU7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgIC8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgxMiAwKVxcXCIgZD1cXFwiTTQgMTIgQTQgNCAwIDAgMCA0IDIwIEE0IDQgMCAwIDAgNCAxMlxcXCI+IFxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCIxMiAwOyAyMiAwOyAyMiAwO1xcXCIgZHVyPVxcXCIwLjhzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjBcXFwiIGtleXRpbWVzPVxcXCIwOy40NTsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAgLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI0IDApXFxcIiBkPVxcXCJNNCAxMiBBNCA0IDAgMCAwIDQgMjAgQTQgNCAwIDAgMCA0IDEyXFxcIj4gXFxuICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9XFxcInRyYW5zZm9ybVxcXCIgdHlwZT1cXFwidHJhbnNsYXRlXFxcIiB2YWx1ZXM9XFxcIjIyIDA7IDMyIDA7IDMyIDA7XFxcIiBkdXI9XFxcIjAuOHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5dGltZXM9XFxcIjA7LjU1OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiICAvPlxcbiAgPC9wYXRoPlxcbjwvc3ZnPlxcblwiXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMilcXFwiIGQ9XFxcIk0wIDEyIFYyMCBINCBWMTJ6XFxcIj4gXFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcImRcXFwiIHZhbHVlcz1cXFwiTTAgMTIgVjIwIEg0IFYxMno7IE0wIDQgVjI4IEg0IFY0ejsgTTAgMTIgVjIwIEg0IFYxMno7IE0wIDEyIFYyMCBINCBWMTJ6XFxcIiBkdXI9XFxcIjEuMnNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5dGltZXM9XFxcIjA7LjI7LjU7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuODswLjIgMC44IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiICAvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoOClcXFwiIGQ9XFxcIk0wIDEyIFYyMCBINCBWMTJ6XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiZFxcXCIgdmFsdWVzPVxcXCJNMCAxMiBWMjAgSDQgVjEyejsgTTAgNCBWMjggSDQgVjR6OyBNMCAxMiBWMjAgSDQgVjEyejsgTTAgMTIgVjIwIEg0IFYxMnpcXFwiIGR1cj1cXFwiMS4yc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjJcXFwiIGtleXRpbWVzPVxcXCIwOy4yOy41OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjg7MC4yIDAuOCAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAgLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDE0KVxcXCIgZD1cXFwiTTAgMTIgVjIwIEg0IFYxMnpcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJkXFxcIiB2YWx1ZXM9XFxcIk0wIDEyIFYyMCBINCBWMTJ6OyBNMCA0IFYyOCBINCBWNHo7IE0wIDEyIFYyMCBINCBWMTJ6OyBNMCAxMiBWMjAgSDQgVjEyelxcXCIgZHVyPVxcXCIxLjJzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuNFxcXCIga2V5dGltZXM9XFxcIjA7LjI7LjU7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuODswLjIgMC44IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyMClcXFwiIGQ9XFxcIk0wIDEyIFYyMCBINCBWMTJ6XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiZFxcXCIgdmFsdWVzPVxcXCJNMCAxMiBWMjAgSDQgVjEyejsgTTAgNCBWMjggSDQgVjR6OyBNMCAxMiBWMjAgSDQgVjEyejsgTTAgMTIgVjIwIEg0IFYxMnpcXFwiIGR1cj1cXFwiMS4yc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjZcXFwiIGtleXRpbWVzPVxcXCIwOy4yOy41OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjg7MC4yIDAuOCAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjYpXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDQgVjEyelxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcImRcXFwiIHZhbHVlcz1cXFwiTTAgMTIgVjIwIEg0IFYxMno7IE0wIDQgVjI4IEg0IFY0ejsgTTAgMTIgVjIwIEg0IFYxMno7IE0wIDEyIFYyMCBINCBWMTJ6XFxcIiBkdXI9XFxcIjEuMnNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC44XFxcIiBrZXl0aW1lcz1cXFwiMDsuMjsuNTsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44OzAuMiAwLjggMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgLz5cXG4gIDwvcGF0aD5cXG48L3N2Zz5cXG5cIlxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIj5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoOCAwKVxcXCIgY3g9XFxcIjBcXFwiIGN5PVxcXCIxNlxcXCIgcj1cXFwiMFxcXCI+IFxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJyXFxcIiB2YWx1ZXM9XFxcIjA7IDQ7IDA7IDBcXFwiIGR1cj1cXFwiMS4yc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwXFxcIlxcbiAgICAgIGtleXRpbWVzPVxcXCIwOzAuMjswLjc7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMTYgMClcXFwiIGN4PVxcXCIwXFxcIiBjeT1cXFwiMTZcXFwiIHI9XFxcIjBcXFwiPiBcXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOyA0OyAwOyAwXFxcIiBkdXI9XFxcIjEuMnNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC4zXFxcIlxcbiAgICAgIGtleXRpbWVzPVxcXCIwOzAuMjswLjc7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjQgMClcXFwiIGN4PVxcXCIwXFxcIiBjeT1cXFwiMTZcXFwiIHI9XFxcIjBcXFwiPiBcXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOyA0OyAwOyAwXFxcIiBkdXI9XFxcIjEuMnNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC42XFxcIlxcbiAgICAgIGtleXRpbWVzPVxcXCIwOzAuMjswLjc7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG48L3N2Zz5cXG5cIlxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIj5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC04IDApXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDggVjEyelxcXCI+IFxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCItOCAwOyAyIDA7IDIgMDtcXFwiIGR1cj1cXFwiMC44c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwXFxcIiBrZXl0aW1lcz1cXFwiMDsuMjU7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgIC8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyIDApXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDggVjEyelxcXCI+IFxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCIyIDA7IDEyIDA7IDEyIDA7XFxcIiBkdXI9XFxcIjAuOHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5dGltZXM9XFxcIjA7LjM1OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiICAvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMTIgMClcXFwiIGQ9XFxcIk0wIDEyIFYyMCBIOCBWMTJ6XFxcIj4gXFxuICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9XFxcInRyYW5zZm9ybVxcXCIgdHlwZT1cXFwidHJhbnNsYXRlXFxcIiB2YWx1ZXM9XFxcIjEyIDA7IDIyIDA7IDIyIDA7XFxcIiBkdXI9XFxcIjAuOHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5dGltZXM9XFxcIjA7LjQ1OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiICAvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjQgMClcXFwiIGQ9XFxcIk0wIDEyIFYyMCBIOCBWMTJ6XFxcIj4gXFxuICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9XFxcInRyYW5zZm9ybVxcXCIgdHlwZT1cXFwidHJhbnNsYXRlXFxcIiB2YWx1ZXM9XFxcIjIyIDA7IDMyIDA7IDMyIDA7XFxcIiBkdXI9XFxcIjAuOHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5dGltZXM9XFxcIjA7LjU1OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiICAvPlxcbiAgPC9wYXRoPlxcbjwvc3ZnPlxcblwiXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMCAwKVxcXCIgZD1cXFwiTTAgMTIgVjIwIEg0IFYxMnpcXFwiPlxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCIwIDA7IDI4IDA7IDAgMDsgMCAwXFxcIiBkdXI9XFxcIjEuNXNcXFwiIGJlZ2luPVxcXCIwXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIga2V5dGltZXM9XFxcIjA7MC4zOzAuNjsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIG9wYWNpdHk9XFxcIjAuNVxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMCAwKVxcXCIgZD1cXFwiTTAgMTIgVjIwIEg0IFYxMnpcXFwiPlxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCIwIDA7IDI4IDA7IDAgMDsgMCAwXFxcIiBkdXI9XFxcIjEuNXNcXFwiIGJlZ2luPVxcXCIwLjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIga2V5dGltZXM9XFxcIjA7MC4zOzAuNjsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIG9wYWNpdHk9XFxcIjAuMjVcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDAgMClcXFwiIGQ9XFxcIk0wIDEyIFYyMCBINCBWMTJ6XFxcIj5cXG4gICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT1cXFwidHJhbnNmb3JtXFxcIiB0eXBlPVxcXCJ0cmFuc2xhdGVcXFwiIHZhbHVlcz1cXFwiMCAwOyAyOCAwOyAwIDA7IDAgMFxcXCIgZHVyPVxcXCIxLjVzXFxcIiBiZWdpbj1cXFwiMC4yc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGtleXRpbWVzPVxcXCIwOzAuMzswLjY7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L3BhdGg+XFxuPC9zdmc+XFxuXCJcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMjVcXFwiIGQ9XFxcIk0xNiAwIEExNiAxNiAwIDAgMCAxNiAzMiBBMTYgMTYgMCAwIDAgMTYgMCBNMTYgNCBBMTIgMTIgMCAwIDEgMTYgMjggQTEyIDEyIDAgMCAxIDE2IDRcXFwiLz5cXG4gIDxwYXRoIGQ9XFxcIk0xNiAwIEExNiAxNiAwIDAgMSAzMiAxNiBMMjggMTYgQTEyIDEyIDAgMCAwIDE2IDR6XFxcIj5cXG4gICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT1cXFwidHJhbnNmb3JtXFxcIiB0eXBlPVxcXCJyb3RhdGVcXFwiIGZyb209XFxcIjAgMTYgMTZcXFwiIHRvPVxcXCIzNjAgMTYgMTZcXFwiIGR1cj1cXFwiMC44c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIC8+XFxuICA8L3BhdGg+XFxuPC9zdmc+XFxuXCJcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+XFxuICA8Y2lyY2xlIGN4PVxcXCIxNlxcXCIgY3k9XFxcIjNcXFwiIHI9XFxcIjBcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJyXFxcIiB2YWx1ZXM9XFxcIjA7MzswOzBcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJyb3RhdGUoNDUgMTYgMTYpXFxcIiBjeD1cXFwiMTZcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIwXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOzM7MDswXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuMTI1c1xcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJyb3RhdGUoOTAgMTYgMTYpXFxcIiBjeD1cXFwiMTZcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIwXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOzM7MDswXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuMjVzXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgLz5cXG4gIDwvY2lyY2xlPlxcbiAgPGNpcmNsZSB0cmFuc2Zvcm09XFxcInJvdGF0ZSgxMzUgMTYgMTYpXFxcIiBjeD1cXFwiMTZcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIwXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOzM7MDswXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuMzc1c1xcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMTgwIDE2IDE2KVxcXCIgY3g9XFxcIjE2XFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMFxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDszOzA7MFxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjVzXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgLz5cXG4gIDwvY2lyY2xlPlxcbiAgPGNpcmNsZSB0cmFuc2Zvcm09XFxcInJvdGF0ZSgyMjUgMTYgMTYpXFxcIiBjeD1cXFwiMTZcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIwXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOzM7MDswXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuNjI1c1xcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMjcwIDE2IDE2KVxcXCIgY3g9XFxcIjE2XFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMFxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDszOzA7MFxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjc1c1xcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMzE1IDE2IDE2KVxcXCIgY3g9XFxcIjE2XFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMFxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDszOzA7MFxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjg3NXNcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwicm90YXRlKDE4MCAxNiAxNilcXFwiIGN4PVxcXCIxNlxcXCIgY3k9XFxcIjNcXFwiIHI9XFxcIjBcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJyXFxcIiB2YWx1ZXM9XFxcIjA7MzswOzBcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC41c1xcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG48L3N2Zz5cXG5cIlxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGlkPVxcXCJsb2FkaW5nXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMVxcXCIgZD1cXFwiTTE0IDAgSDE4IFY4IEgxNCB6XFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSgwIDE2IDE2KVxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcIm9wYWNpdHlcXFwiIGZyb209XFxcIjFcXFwiIHRvPVxcXCIuMVxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwXFxcIi8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMVxcXCIgZD1cXFwiTTE0IDAgSDE4IFY4IEgxNCB6XFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSg0NSAxNiAxNilcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJvcGFjaXR5XFxcIiBmcm9tPVxcXCIxXFxcIiB0bz1cXFwiLjFcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC4xMjVzXFxcIi8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMVxcXCIgZD1cXFwiTTE0IDAgSDE4IFY4IEgxNCB6XFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSg5MCAxNiAxNilcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJvcGFjaXR5XFxcIiBmcm9tPVxcXCIxXFxcIiB0bz1cXFwiLjFcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC4yNXNcXFwiLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIG9wYWNpdHk9XFxcIi4xXFxcIiBkPVxcXCJNMTQgMCBIMTggVjggSDE0IHpcXFwiIHRyYW5zZm9ybT1cXFwicm90YXRlKDEzNSAxNiAxNilcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJvcGFjaXR5XFxcIiBmcm9tPVxcXCIxXFxcIiB0bz1cXFwiLjFcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC4zNzVzXFxcIi8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMVxcXCIgZD1cXFwiTTE0IDAgSDE4IFY4IEgxNCB6XFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSgxODAgMTYgMTYpXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgZnJvbT1cXFwiMVxcXCIgdG89XFxcIi4xXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuNXNcXFwiLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIG9wYWNpdHk9XFxcIi4xXFxcIiBkPVxcXCJNMTQgMCBIMTggVjggSDE0IHpcXFwiIHRyYW5zZm9ybT1cXFwicm90YXRlKDIyNSAxNiAxNilcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJvcGFjaXR5XFxcIiBmcm9tPVxcXCIxXFxcIiB0bz1cXFwiLjFcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC42NzVzXFxcIi8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMVxcXCIgZD1cXFwiTTE0IDAgSDE4IFY4IEgxNCB6XFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSgyNzAgMTYgMTYpXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgZnJvbT1cXFwiMVxcXCIgdG89XFxcIi4xXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuNzVzXFxcIi8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMVxcXCIgZD1cXFwiTTE0IDAgSDE4IFY4IEgxNCB6XFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSgzMTUgMTYgMTYpXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgZnJvbT1cXFwiMVxcXCIgdG89XFxcIi4xXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuODc1c1xcXCIvPlxcbiAgPC9wYXRoPlxcbjwvc3ZnPlxcblwiXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtbG9hZGluZy5qcy5tYXAiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJzZWxmIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsIm4iLCJfX2VzTW9kdWxlIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsInByb2Nlc3MiLCJ1bmRlZmluZWQiLCJFcnJvciIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImEiLCJiIiwiZSIsImYiLCJlcnJvciIsImFyZ3MiLCJhcmdJbmRleCIsInJlcGxhY2UiLCJmcmFtZXNUb1BvcCIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwiZW1wdHlGdW5jdGlvbiIsInRoYXRSZXR1cm5zIiwidGhhdFJldHVybnNGYWxzZSIsInRoYXRSZXR1cm5zVHJ1ZSIsInRoYXRSZXR1cm5zTnVsbCIsInRoYXRSZXR1cm5zVGhpcyIsInRoYXRSZXR1cm5zQXJndW1lbnQiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsImFzc2lnbiIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibWFwIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJmb3JFYWNoIiwibGV0dGVyIiwia2V5cyIsImVyciIsInRhcmdldCIsInNvdXJjZSIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJrZXkiLCJ3YXJuaW5nIiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIkFycmF5IiwiX2tleSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwieCIsImluZGV4T2YiLCJfbGVuMiIsIl9rZXkyIiwiYXBwbHkiLCJjb25jYXQiLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4Iiwic3RhY2siLCJ2YWx1ZSIsIl9leHRlbmRzIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIndyaXRhYmxlIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfcmVhY3QiLCJfcmVhY3QyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9wcm9wVHlwZXMiLCJfcHJvcFR5cGVzMiIsIl9zdmciLCJzdmdTb3VyY2VzIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJvYmoiLCJuZXdPYmoiLCJkZWZhdWx0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkxvYWRpbmciLCJfQ29tcG9uZW50IiwiX3JlZiIsIl90ZW1wIiwiX3RoaXMiLCJfcmV0IiwiZ2V0UHJvdG90eXBlT2YiLCJzdGF0ZSIsImRlbGF5ZWQiLCJkZWxheSIsImNvbXBvbmVudERpZE1vdW50IiwiX3RoaXMyIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJzZXRTdGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY2xlYXJUaW1lb3V0IiwicmVuZGVyIiwiX3Byb3BzIiwiY29sb3IiLCJ0eXBlIiwiaGVpZ2h0Iiwid2lkdGgiLCJyZXN0UHJvcHMiLCJzZWxlY3RlZFR5cGUiLCJzdmciLCJzdHlsZSIsImZpbGwiLCJjcmVhdGVFbGVtZW50IiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJzdHJpbmciLCJudW1iZXIiLCJvbmVPZlR5cGUiLCJkZWZhdWx0UHJvcHMiLCJxIiwiciIsIlN5bWJvbCIsInQiLCJ1IiwidiIsInciLCJ5IiwieiIsIkEiLCJCIiwiaXRlcmF0b3IiLCJDIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiRCIsImlzTW91bnRlZCIsImVucXVldWVGb3JjZVVwZGF0ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlU2V0U3RhdGUiLCJFIiwiY29udGV4dCIsInJlZnMiLCJ1cGRhdGVyIiwiaXNSZWFjdENvbXBvbmVudCIsImZvcmNlVXBkYXRlIiwiRiIsIkciLCJIIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJJIiwiY3VycmVudCIsIkoiLCJLIiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJMIiwiZyIsImgiLCJjaGlsZHJlbiIsImsiLCIkJHR5cGVvZiIsIl9vd25lciIsIk0iLCJlc2NhcGUiLCJOIiwiTyIsIlAiLCJwb3AiLCJyZXN1bHQiLCJrZXlQcmVmaXgiLCJmdW5jIiwiY291bnQiLCJRIiwicHVzaCIsIlIiLCJTIiwiaXNBcnJheSIsIm5leHQiLCJkb25lIiwidG9TdHJpbmciLCJUIiwiVSIsIlYiLCJXIiwiQ2hpbGRyZW4iLCJ0b0FycmF5Iiwib25seSIsImNyZWF0ZVJlZiIsIlB1cmVDb21wb25lbnQiLCJjcmVhdGVDb250ZXh0IiwiX2NhbGN1bGF0ZUNoYW5nZWRCaXRzIiwiX2RlZmF1bHRWYWx1ZSIsIl9jdXJyZW50VmFsdWUiLCJfY2hhbmdlZEJpdHMiLCJQcm92aWRlciIsIkNvbnN1bWVyIiwiX2NvbnRleHQiLCJmb3J3YXJkUmVmIiwiRnJhZ21lbnQiLCJTdHJpY3RNb2RlIiwidW5zdGFibGVfQXN5bmNNb2RlIiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlRmFjdG9yeSIsImJpbmQiLCJpc1ZhbGlkRWxlbWVudCIsInZlcnNpb24iLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwiWCIsIlkiLCJfYXNzaWduIiwiUmVhY3RWZXJzaW9uIiwiaGFzU3ltYm9sIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfQ0FMTF9UWVBFIiwiUkVBQ1RfUkVUVVJOX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0FTWU5DX01PREVfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsImxvd1ByaW9yaXR5V2FybmluZyIsIndhcm4iLCJsb3dQcmlvcml0eVdhcm5pbmckMSIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCIsIndhcm5Ob29wIiwicHVibGljSW5zdGFuY2UiLCJjYWxsZXJOYW1lIiwiX2NvbnN0cnVjdG9yIiwiZGlzcGxheU5hbWUiLCJ3YXJuaW5nS2V5IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJjYWxsYmFjayIsImNvbXBsZXRlU3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJkZXByZWNhdGVkQVBJcyIsInJlcGxhY2VTdGF0ZSIsImRlZmluZURlcHJlY2F0aW9uV2FybmluZyIsIm1ldGhvZE5hbWUiLCJpbmZvIiwiZm5OYW1lIiwiQ29tcG9uZW50RHVtbXkiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwicmVmT2JqZWN0Iiwic2VhbCIsIlJFU0VSVkVEX1BST1BTIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJvd25lciIsImVsZW1lbnQiLCJfc3RvcmUiLCJwcm9wTmFtZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImNsb25lQW5kUmVwbGFjZUtleSIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50IiwiX3NlbGYiLCJfc291cmNlIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsImdldEN1cnJlbnRTdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJpbXBsIiwiU0VQQVJBVE9SIiwiU1VCU0VQQVJBVE9SIiwiZXNjYXBlUmVnZXgiLCJlc2NhcGVyTG9va3VwIiwiZXNjYXBlZFN0cmluZyIsIm1hdGNoIiwiZGlkV2FybkFib3V0TWFwcyIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwidGV4dCIsIlBPT0xfU0laRSIsInRyYXZlcnNlQ29udGV4dFBvb2wiLCJnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQiLCJtYXBSZXN1bHQiLCJtYXBGdW5jdGlvbiIsIm1hcENvbnRleHQiLCJ0cmF2ZXJzZUNvbnRleHQiLCJyZWxlYXNlVHJhdmVyc2VDb250ZXh0IiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJpbnZva2VDYWxsYmFjayIsImdldENvbXBvbmVudEtleSIsImNoaWxkIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwic3RlcCIsImlpIiwiYWRkZW5kdW0iLCJjaGlsZHJlblN0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJjb21wb25lbnQiLCJpbmRleCIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsImFycmF5IiwicHJlZml4IiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiY291bnRDaGlsZHJlbiIsIm9ubHlDaGlsZCIsImRlZmF1bHRWYWx1ZSIsImNhbGN1bGF0ZUNoYW5nZWRCaXRzIiwiX2N1cnJlbnRSZW5kZXJlciIsImRlc2NyaWJlQ29tcG9uZW50RnJhbWUiLCJvd25lck5hbWUiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJnZXRDb21wb25lbnROYW1lIiwiZmliZXIiLCJmdW5jdGlvbk5hbWUiLCJjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImVsZW1lbnRQcm9wcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwiY29tcG9uZW50Q2xhc3MiLCJQcm9wVHlwZXMiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50IiwiY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInR5cGVTdHJpbmciLCJjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24iLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJSZWFjdCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJSZWFjdCQyIiwiUmVhY3QkMyIsInJlYWN0IiwiZm9yIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsIklURVJBVE9SX1NZTUJPTCIsIkFOT05ZTU9VUyIsIlJlYWN0UHJvcFR5cGVzIiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJib29sIiwic3ltYm9sIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsInNoYXBlIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImV4YWN0IiwiY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlciIsImlzIiwiUHJvcFR5cGVFcnJvciIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSIsIm1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNhY2hlS2V5IiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwiZXZlcnkiLCJlbnRyeSIsImlzU3ltYm9sIiwiUmVnRXhwIiwiRGF0ZSIsInNoaW0iLCJnZXRTaGltIiwiX2JsYW5rIiwiX2xvYWRpbmdCYWxscyIsIl9sb2FkaW5nQmFycyIsIl9sb2FkaW5nQnViYmxlcyIsIl9sb2FkaW5nQ3ViZXMiLCJfbG9hZGluZ0N5bG9uIiwiX2xvYWRpbmdTcGluIiwiX2xvYWRpbmdTcGlubmluZ0J1YmJsZXMiLCJfbG9hZGluZ1Nwb2tlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-loading/dist/react-loading.js\n");

/***/ })

};
;