"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/superstruct";
exports.ids = ["vendor-chunks/superstruct"];
exports.modules = {

/***/ "(ssr)/./node_modules/superstruct/lib/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/superstruct/lib/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : \"At path: \" + path.join(\".\") + \" -- \" + message;\n        super(msg);\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            var _cached;\n            return (_cached = cached) != null ? _cached : cached = [\n                failure,\n                ...failures()\n            ];\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    return typeof value === \"string\" ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : \"\") + \", but received: `\" + print(value) + \"`\" } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options = {}) {\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for(const key in value){\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let valid = true;\n    for (const failure of struct.validator(value, ctx)){\n        valid = false;\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask\n        });\n        for (const t of ts){\n            if (t[0]) {\n                valid = false;\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    value[k] = v;\n                }\n            }\n        }\n    }\n    if (valid) {\n        for (const failure of struct.refiner(value, ctx)){\n            valid = false;\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (valid) {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */ assert(value) {\n        return assert(value, this);\n    }\n    /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */ create(value) {\n        return create(value, this);\n    }\n    /**\n   * Check if a value passes the struct's validation.\n   */ is(value) {\n        return is(value, this);\n    }\n    /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */ mask(value) {\n        return mask(value, this);\n    }\n    /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */ validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct) {\n    const result = validate(value, struct);\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign(...Structs) {\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            var _struct;\n            (_struct = struct) != null ? _struct : struct = fn();\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            var _struct2;\n            (_struct2 = struct) != null ? _struct2 : struct = fn();\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            var _struct3;\n            (_struct3 = struct) != null ? _struct3 : struct = fn();\n            return struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const schema = struct instanceof Struct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || \"Expected a function, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n    });\n}\nfunction intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || \"Expected a string, but received: \" + print(value);\n    });\n}\nfunction tuple(Elements) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Elements.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Elements[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\nfunction union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                \"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value),\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    const expected = \"Expected an empty \" + struct.type;\n    return refine(struct, \"empty\", (value)=>{\n        if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return size === 0 || expected + \" but received one with a size of `\" + size + \"`\";\n        } else {\n            const { length } = value;\n            return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n        }\n    });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + '/` but received \"' + value + '\"';\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max = min) {\n    const expected = \"Expected a \" + struct.type;\n    const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVEOzs7Ozs7O0NBT0MsR0FDRCxNQUFNQSxvQkFBb0JDO0lBQ3hCQyxZQUFZQyxPQUFPLEVBQUVDLFFBQVEsQ0FBRTtRQUM3QixJQUFJQztRQUNKLE1BQU0sRUFDSkMsT0FBTyxFQUNQLEdBQUdDLE1BQ0osR0FBR0o7UUFDSixNQUFNLEVBQ0pLLElBQUksRUFDTCxHQUFHTDtRQUNKLE1BQU1NLE1BQU1ELEtBQUtFLE1BQU0sS0FBSyxJQUFJSixVQUFVLGNBQWNFLEtBQUtHLElBQUksQ0FBQyxPQUFPLFNBQVNMO1FBQ2xGLEtBQUssQ0FBQ0c7UUFDTkcsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRU47UUFDcEIsSUFBSSxDQUFDTyxJQUFJLEdBQUcsSUFBSSxDQUFDWixXQUFXLENBQUNZLElBQUk7UUFFakMsSUFBSSxDQUFDVixRQUFRLEdBQUc7WUFDZCxJQUFJVztZQUVKLE9BQU8sQ0FBQ0EsVUFBVVYsTUFBSyxLQUFNLE9BQU9VLFVBQVVWLFNBQVM7Z0JBQUNGO21CQUFZQzthQUFXO1FBQ2pGO0lBQ0Y7QUFFRjtBQUVBOztDQUVDLEdBQ0QsU0FBU1ksV0FBV0MsQ0FBQztJQUNuQixPQUFPQyxTQUFTRCxNQUFNLE9BQU9BLENBQUMsQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDLEtBQUs7QUFDdEQ7QUFDQTs7Q0FFQyxHQUdELFNBQVNGLFNBQVNELENBQUM7SUFDakIsT0FBTyxPQUFPQSxNQUFNLFlBQVlBLEtBQUs7QUFDdkM7QUFDQTs7Q0FFQyxHQUVELFNBQVNJLGNBQWNKLENBQUM7SUFDdEIsSUFBSUwsT0FBT1UsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1AsT0FBTyxtQkFBbUI7UUFDM0QsT0FBTztJQUNUO0lBRUEsTUFBTUss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QSxVQUFVLFlBQVlBLGlCQUFpQjZFLE1BQU07WUFDdEQsT0FBT29ELE9BQU9qSSxTQUFTQSxTQUFTNkcsT0FBT2UsV0FBVyxNQUFNUyxLQUFLLG9CQUFvQnJJLFFBQVE7UUFDM0YsT0FBTyxJQUFJQSxpQkFBaUJtQyxPQUFPbkMsaUJBQWlCcUMsS0FBSztZQUN2RCxNQUFNLEVBQ0p5RixJQUFJLEVBQ0wsR0FBRzlIO1lBQ0osT0FBT2lJLE9BQU9ILFFBQVFBLFFBQVFqQixPQUFPZSxXQUFXLGtCQUFrQlMsS0FBSyx1Q0FBdUNQLE9BQU87UUFDdkgsT0FBTztZQUNMLE1BQU0sRUFDSi9JLE1BQU0sRUFDUCxHQUFHaUI7WUFDSixPQUFPaUksT0FBT2xKLFVBQVVBLFVBQVU4SCxPQUFPZSxXQUFXLG9CQUFvQlMsS0FBSyx5Q0FBeUN0SixTQUFTO1FBQ2pJO0lBQ0Y7QUFDRjtBQUNBOzs7Ozs7Q0FNQyxHQUVELFNBQVM4SSxPQUFPbEgsTUFBTSxFQUFFeEIsSUFBSSxFQUFFb0QsT0FBTztJQUNuQyxPQUFPLElBQUlDLE9BQU87UUFBRSxHQUFHN0IsTUFBTTtRQUUzQixDQUFDNEIsU0FBUXZDLEtBQUssRUFBRXNCLEdBQUc7WUFDakIsT0FBT1gsT0FBTzRCLE9BQU8sQ0FBQ3ZDLE9BQU9zQjtZQUM3QixNQUFNYixTQUFTOEIsUUFBUXZDLE9BQU9zQjtZQUM5QixNQUFNN0MsV0FBV3VDLFdBQVdQLFFBQVFhLEtBQUtYLFFBQVFYO1lBRWpELEtBQUssTUFBTXhCLFdBQVdDLFNBQVU7Z0JBQzlCLE1BQU07b0JBQUUsR0FBR0QsT0FBTztvQkFDaEJzQyxZQUFZM0I7Z0JBQ2Q7WUFDRjtRQUNGO0lBRUY7QUFDRjtBQUUyWSxDQUMzWSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2xhbmFfd2FsbGV0X3RyYWNrZXIvLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzPzY5MDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIFZhbGlkYXRpb24gbG9naWMgaXMgZGVzaWduIHRvIGV4aXQgZWFybHkgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UuIFRoZSBlcnJvclxuICogcmVwcmVzZW50cyB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHZhbGlkYXRpb24uIEZvciBtb3JlIGRldGFpbCxcbiAqIHRoZSBgZXJyb3IuZmFpbHVyZXNgIHByb3BlcnR5IGlzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHJ1biB0b1xuICogY29udGludWUgdmFsaWRhdGlvbiBhbmQgcmVjZWl2ZSBhbGwgdGhlIGZhaWx1cmVzIGluIHRoZSBkYXRhLlxuICovXG5jbGFzcyBTdHJ1Y3RFcnJvciBleHRlbmRzIFR5cGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgbGV0IGNhY2hlZDtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBmYWlsdXJlO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhcbiAgICB9ID0gZmFpbHVyZTtcbiAgICBjb25zdCBtc2cgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBcIkF0IHBhdGg6IFwiICsgcGF0aC5qb2luKCcuJykgKyBcIiAtLSBcIiArIG1lc3NhZ2U7XG4gICAgc3VwZXIobXNnKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NhY2hlZDtcblxuICAgICAgcmV0dXJuIChfY2FjaGVkID0gY2FjaGVkKSAhPSBudWxsID8gX2NhY2hlZCA6IGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXTtcbiAgICB9O1xuICB9XG5cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHgpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPSBudWxsO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBwcmludCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFwiXCIgKyB2YWx1ZTtcbn1cbi8qKlxuICogU2hpZnRzIChyZW1vdmVzIGFuZCByZXR1cm5zKSB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgYGlucHV0YCBpdGVyYXRvci5cbiAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gKi9cblxuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICBjb25zdCB7XG4gICAgZG9uZSxcbiAgICB2YWx1ZVxuICB9ID0gaW5wdXQubmV4dCgpO1xuICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHZhbGlkYXRpb24gcmVzdWx0IHRvIGEgZmFpbHVyZS5cbiAqL1xuXG5mdW5jdGlvbiB0b0ZhaWx1cmUocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgbWVzc2FnZTogcmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBwYXRoLFxuICAgIGJyYW5jaFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qge1xuICAgIHJlZmluZW1lbnQsXG4gICAgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIGBcIiArIHR5cGUgKyBcImBcIiArIChyZWZpbmVtZW50ID8gXCIgd2l0aCByZWZpbmVtZW50IGBcIiArIHJlZmluZW1lbnQgKyBcImBcIiA6ICcnKSArIFwiLCBidXQgcmVjZWl2ZWQ6IGBcIiArIHByaW50KHZhbHVlKSArIFwiYFwiXG4gIH0gPSByZXN1bHQ7XG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgdHlwZSxcbiAgICByZWZpbmVtZW50LFxuICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgIHBhdGgsXG4gICAgYnJhbmNoLFxuICAgIC4uLnJlc3VsdCxcbiAgICBtZXNzYWdlXG4gIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhbiBpdGVyYWJsZSBvZiBmYWlsdXJlcy5cbiAqL1xuXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgaWYgKCFpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgfVxuXG4gIGZvciAoY29uc3QgciBvZiByZXN1bHQpIHtcbiAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuXG4gICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAqIHJldHVybmluZyBhbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICovXG5cbmZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwYXRoID0gW10sXG4gICAgYnJhbmNoID0gW3ZhbHVlXSxcbiAgICBjb2VyY2UgPSBmYWxzZSxcbiAgICBtYXNrID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGN0eCA9IHtcbiAgICBwYXRoLFxuICAgIGJyYW5jaFxuICB9O1xuXG4gIGlmIChjb2VyY2UpIHtcbiAgICB2YWx1ZSA9IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuXG4gICAgaWYgKG1hc2sgJiYgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJiBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RydWN0LnNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB2YWxpZCA9IHRydWU7XG5cbiAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCkpIHtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICB9XG5cbiAgZm9yIChsZXQgW2ssIHYsIHNdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpKSB7XG4gICAgY29uc3QgdHMgPSBydW4odiwgcywge1xuICAgICAgcGF0aDogayA9PT0gdW5kZWZpbmVkID8gcGF0aCA6IFsuLi5wYXRoLCBrXSxcbiAgICAgIGJyYW5jaDogayA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgdl0sXG4gICAgICBjb2VyY2UsXG4gICAgICBtYXNrXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIHlpZWxkIFt0WzBdLCB1bmRlZmluZWRdO1xuICAgICAgfSBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgdiA9IHRbMV07XG5cbiAgICAgICAgaWYgKGsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgIHZhbHVlLnNldChrLCB2KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgIHZhbHVlLmFkZCh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWQpIHtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCkpIHtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWQpIHtcbiAgICB5aWVsZCBbdW5kZWZpbmVkLCB2YWx1ZV07XG4gIH1cbn1cblxuLyoqXG4gKiBgU3RydWN0YCBvYmplY3RzIGVuY2Fwc3VsYXRlIHRoZSB2YWxpZGF0aW9uIGxvZ2ljIGZvciBhIHNwZWNpZmljIHR5cGUgb2ZcbiAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gKiB2YWxpZGF0ZSB1bmtub3duIGlucHV0IGRhdGEgYWdhaW5zdCB0aGUgc3RydWN0LlxuICovXG5cbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIHZhbGlkYXRvcixcbiAgICAgIHJlZmluZXIsXG4gICAgICBjb2VyY2VyID0gdmFsdWUgPT4gdmFsdWUsXG4gICAgICBlbnRyaWVzID0gZnVuY3Rpb24qICgpIHt9XG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB0aGlzLmNvZXJjZXIgPSBjb2VyY2VyO1xuXG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgIH1cblxuICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICovXG5cblxuICBhc3NlcnQodmFsdWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAqL1xuXG5cbiAgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLlxuICAgKi9cblxuXG4gIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBkZWZpbmVkIGJ5IHRoZSBzdHJ1Y3QncyBzY2hlbWEuXG4gICAqL1xuXG5cbiAgbWFzayh2YWx1ZSkge1xuICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICpcbiAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgKi9cblxuXG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHtcbiAgICBjb2VyY2U6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0WzFdO1xuICB9XG59XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKi9cblxuZnVuY3Rpb24gbWFzayh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHtcbiAgICBjb2VyY2U6IHRydWUsXG4gICAgbWFzazogdHJ1ZVxuICB9KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHRbMV07XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QuXG4gKi9cblxuZnVuY3Rpb24gaXModmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcbiAgcmV0dXJuICFyZXN1bHRbMF07XG59XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICBjb25zdCB0dXBsZSA9IHNoaWZ0SXRlcmF0b3IodHVwbGVzKTtcblxuICBpZiAodHVwbGVbMF0pIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICB5aWVsZCB0WzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtlcnJvciwgdW5kZWZpbmVkXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHZdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiguLi5TdHJ1Y3RzKSB7XG4gIGNvbnN0IHNjaGVtYXMgPSBTdHJ1Y3RzLm1hcChzID0+IHMuc2NoZW1hKTtcbiAgY29uc3Qgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2NoZW1hcyk7XG4gIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiBuYW1lLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICB2YWxpZGF0b3JcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgc3RydWN0LCBidXQgdGhlIHZhbHVlIGlzIGFsbG93ZWQgdG9cbiAqIGJlIGB1bmRlZmluZWRgLiBgbG9nYCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlxuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2codmFsdWUsIGN0eCk7XG4gICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggZHluYW1pYyB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdGhlIHZhbHVlIGN1cnJlbnRseSBiZWluZyB2YWxpZGF0ZWQsIGFuZCBtdXN0XG4gKiByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHZhbGlkYXRlIGl0IHdpdGguIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBtb2RlbFxuICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICovXG5cbmZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAqIGFuZCBtdXN0IHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdXNlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91XG4gKiB3YW50IHRvIGhhdmUgc2VsZi1yZWZlcmVudGlhbCBzdHJ1Y3RzIGZvciBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzIHRvIGF2b2lkIGFcbiAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAqL1xuXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gIGxldCBzdHJ1Y3Q7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbGF6eScsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgdmFyIF9zdHJ1Y3Q7XG5cbiAgICAgIChfc3RydWN0ID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdCA6IHN0cnVjdCA9IGZuKCk7XG4gICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDI7XG5cbiAgICAgIChfc3RydWN0MiA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3QyIDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHZhciBfc3RydWN0MztcblxuICAgICAgKF9zdHJ1Y3QzID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdDMgOiBzdHJ1Y3QgPSBmbigpO1xuICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIG9taXQoc3RydWN0LCBrZXlzKSB7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWFcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWFcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZGVsZXRlIHN1YnNjaGVtYVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aWFsKHN0cnVjdCkge1xuICBjb25zdCBzY2hlbWEgPSBzdHJ1Y3QgaW5zdGFuY2VvZiBTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWFcbiAgfSA6IHsgLi4uc3RydWN0XG4gIH07XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IG9ubHkgaW5jbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQaWNrYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWFcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qgc3Vic2NoZW1hID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICovXG5cbmZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICByZXR1cm4gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcik7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGFueSgpIHtcbiAgcmV0dXJuIGRlZmluZSgnYW55JywgKCkgPT4gdHJ1ZSk7XG59XG5mdW5jdGlvbiBhcnJheShFbGVtZW50KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIHNjaGVtYTogRWxlbWVudCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoRWxlbWVudCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbaSwgdiwgRWxlbWVudF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKi9cblxuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgcmV0dXJuIGRlZmluZSgnYm9vbGVhbicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5cbmZ1bmN0aW9uIGRhdGUoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2RhdGUnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSB8fCBcIkV4cGVjdGVkIGEgdmFsaWQgYERhdGVgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgY29uc3Qgc2NoZW1hID0ge307XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVzLm1hcCh2ID0+IHByaW50KHYpKS5qb2luKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gIH1cblxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2VudW1zJyxcbiAgICBzY2hlbWEsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8IFwiRXhwZWN0ZWQgb25lIG9mIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2Z1bmMnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBcIkV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW5zdGFuY2UnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHwgXCJFeHBlY3RlZCBhIGBcIiArIENsYXNzLm5hbWUgKyBcImAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cblxuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oU3RydWN0cykge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHByaW50KGNvbnN0YW50KTtcbiAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICBzY2hlbWE6IHQgPT09ICdzdHJpbmcnIHx8IHQgPT09ICdudW1iZXInIHx8IHQgPT09ICdib29sZWFuJyA/IGNvbnN0YW50IDogbnVsbCxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBjb25zdGFudCB8fCBcIkV4cGVjdGVkIHRoZSBsaXRlcmFsIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hcChLZXksIFZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbWFwJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEtleSAmJiBWYWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IFwiRXhwZWN0ZWQgYSBgTWFwYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIG5ldmVyKCkge1xuICByZXR1cm4gZGVmaW5lKCduZXZlcicsICgpID0+IGZhbHNlKTtcbn1cbi8qKlxuICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBudWxsYWJsZShzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eClcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cblxuZnVuY3Rpb24gbnVtYmVyKCkge1xuICByZXR1cm4gZGVmaW5lKCdudW1iZXInLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSB8fCBcIkV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdChzY2hlbWEpIHtcbiAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYSA6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdW5rbm93bnMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25zKSB7XG4gICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZVxuICAgICAgfSA6IHZhbHVlO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gb3B0aW9uYWwoc3RydWN0KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUmVjb3JkYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHJlY29yZChLZXksIFZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAncmVjb3JkJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwKCkge1xuICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEVsZW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgeWllbGQgW3YsIHYsIEVsZW1lbnRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldCA/IG5ldyBTZXQodmFsdWUpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8IFwiRXhwZWN0ZWQgYSBgU2V0YCBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHN0cmluZygpIHtcbiAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IFwiRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdHVwbGUoRWxlbWVudHMpIHtcbiAgY29uc3QgTmV2ZXIgPSBuZXZlcigpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R1cGxlJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KEVsZW1lbnRzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgeWllbGQgW2ksIHZhbHVlW2ldLCBFbGVtZW50c1tpXSB8fCBOZXZlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBhcnJheSwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICovXG5cbmZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R5cGUnLFxuICAgIHNjaGVtYSxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG5mdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAocyA9PiBzLnR5cGUpLmpvaW4oJyB8ICcpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3VuaW9uJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgY29uc3QgWy4uLnR1cGxlc10gPSBydW4odmFsdWUsIFMsIGN0eCk7XG4gICAgICAgIGNvbnN0IFtmaXJzdF0gPSB0dXBsZXM7XG5cbiAgICAgICAgaWYgKCFmaXJzdFswXSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXCJFeHBlY3RlZCB0aGUgdmFsdWUgdG8gc2F0aXNmeSBhIHVuaW9uIG9mIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpLCAuLi5mYWlsdXJlc107XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24sIHdpdGhvdXQgd2lkZW5pbmcgaXRzIHR5cGUgdG8gYGFueWAuXG4gKi9cblxuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgcmV0dXJuIGRlZmluZSgndW5rbm93bicsICgpID0+IHRydWUpO1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCBjb2VyY2lvbiBzdGVwIHRvIGl0cyBpbnB1dC5cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIGlucHV0IGRhdGEgYmVmb3JlIHZhbGlkYXRpbmcgaXQsIHRvIGluY3JlYXNlIHRoZVxuICogbGlrZWxpaG9vZCB0aGF0IGl0IHBhc3NlcyB2YWxpZGF0aW9u4oCUZm9yIGV4YW1wbGUgZm9yIGRlZmF1bHQgdmFsdWVzLCBwYXJzaW5nXG4gKiBkaWZmZXJlbnQgZm9ybWF0cywgZXRjLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgcmV0dXJuIGlzKHZhbHVlLCBjb25kaXRpb24pID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KSA6IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gcmVwbGFjZSBgdW5kZWZpbmVkYCB2YWx1ZXMgd2l0aCBhIGRlZmF1bHQuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdGVkKHN0cnVjdCwgZmFsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgdW5rbm93bigpLCB4ID0+IHtcbiAgICBjb25zdCBmID0gdHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2soKSA6IGZhbGxiYWNrO1xuXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGY7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgLi4ueFxuICAgICAgfTtcbiAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGZba2V5XTtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB4O1xuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCB4ID0+IHgudHJpbSgpKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5KHN0cnVjdCkge1xuICBjb25zdCBleHBlY3RlZCA9IFwiRXhwZWN0ZWQgYW4gZW1wdHkgXCIgKyBzdHJ1Y3QudHlwZTtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsIHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2l6ZVxuICAgICAgfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHNpemUgPT09IDAgfHwgZXhwZWN0ZWQgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIGBcIiArIHNpemUgKyBcImBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBsZW5ndGggPT09IDAgfHwgZXhwZWN0ZWQgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgYFwiICsgbGVuZ3RoICsgXCJgXCI7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqL1xuXG5mdW5jdGlvbiBtYXgoc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZXhjbHVzaXZlXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21heCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlID8gdmFsdWUgPCB0aHJlc2hvbGQgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBncmVhdGVyIHRoYW4gXCIgKyAoZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJykgKyB0aHJlc2hvbGQgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKi9cblxuZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGV4Y2x1c2l2ZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtaW4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIGV4Y2x1c2l2ZSA/IHZhbHVlID4gdGhyZXNob2xkIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8IFwiRXhwZWN0ZWQgYSBcIiArIHN0cnVjdC50eXBlICsgXCIgZ3JlYXRlciB0aGFuIFwiICsgKGV4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICcpICsgdGhyZXNob2xkICsgXCIgYnV0IHJlY2VpdmVkIGBcIiArIHZhbHVlICsgXCJgXCI7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG5cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiByZWdleHAudGVzdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBtYXRjaGluZyBgL1wiICsgcmVnZXhwLnNvdXJjZSArIFwiL2AgYnV0IHJlY2VpdmVkIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCI7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG51bWJlciwgZGF0ZSwgbWFwLCBvciBzZXQgaGFzIGEgc2l6ZSAob3IgbGVuZ3RoLCBvciB0aW1lKSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqL1xuXG5mdW5jdGlvbiBzaXplKHN0cnVjdCwgbWluLCBtYXggPSBtaW4pIHtcbiAgY29uc3QgZXhwZWN0ZWQgPSBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZTtcbiAgY29uc3Qgb2YgPSBtaW4gPT09IG1heCA/IFwib2YgYFwiICsgbWluICsgXCJgXCIgOiBcImJldHdlZW4gYFwiICsgbWluICsgXCJgIGFuZCBgXCIgKyBtYXggKyBcImBcIjtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdzaXplJywgdmFsdWUgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIGBcIiArIHZhbHVlICsgXCJgXCI7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaXplXG4gICAgICB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gbWluIDw9IHNpemUgJiYgc2l6ZSA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiB3aXRoIGEgc2l6ZSBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBgXCIgKyBzaXplICsgXCJgXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gbWluIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gbWF4IHx8IGV4cGVjdGVkICsgXCIgd2l0aCBhIGxlbmd0aCBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIGBcIiArIGxlbmd0aCArIFwiYFwiO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCByZWZpbmVtZW50IHRvIHRoZSB2YWxpZGF0aW9uLlxuICpcbiAqIFRoZSByZWZpbmVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmVjZWl2ZSBhIHZhbHVlIG9mIHRoZSBzdHJ1Y3QncyB0eXBlLFxuICogYmVjYXVzZSB0aGUgc3RydWN0J3MgZXhpc3RpbmcgdmFsaWRhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBwYXNzZWQuIFRoaXNcbiAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICovXG5cbmZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG5cbiAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICB5aWVsZCogc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgY29uc3QgZmFpbHVyZXMgPSB0b0ZhaWx1cmVzKHJlc3VsdCwgY3R4LCBzdHJ1Y3QsIHZhbHVlKTtcblxuICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSxcbiAgICAgICAgICByZWZpbmVtZW50OiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBTdHJ1Y3QsIFN0cnVjdEVycm9yLCBhbnksIGFycmF5LCBhc3NlcnQsIGFzc2lnbiwgYm9vbGVhbiwgY29lcmNlLCBjcmVhdGUsIGRhdGUsIGRlZmF1bHRlZCwgZGVmaW5lLCBkZXByZWNhdGVkLCBkeW5hbWljLCBlbXB0eSwgZW51bXMsIGZ1bmMsIGluc3RhbmNlLCBpbnRlZ2VyLCBpbnRlcnNlY3Rpb24sIGlzLCBsYXp5LCBsaXRlcmFsLCBtYXAsIG1hc2ssIG1heCwgbWluLCBuZXZlciwgbnVsbGFibGUsIG51bWJlciwgb2JqZWN0LCBvbWl0LCBvcHRpb25hbCwgcGFydGlhbCwgcGF0dGVybiwgcGljaywgcmVjb3JkLCByZWZpbmUsIHJlZ2V4cCwgc2V0LCBzaXplLCBzdHJpbmcsIHN0cnVjdCwgdHJpbW1lZCwgdHVwbGUsIHR5cGUsIHVuaW9uLCB1bmtub3duLCB2YWxpZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOlsiU3RydWN0RXJyb3IiLCJUeXBlRXJyb3IiLCJjb25zdHJ1Y3RvciIsImZhaWx1cmUiLCJmYWlsdXJlcyIsImNhY2hlZCIsIm1lc3NhZ2UiLCJyZXN0IiwicGF0aCIsIm1zZyIsImxlbmd0aCIsImpvaW4iLCJPYmplY3QiLCJhc3NpZ24iLCJuYW1lIiwiX2NhY2hlZCIsImlzSXRlcmFibGUiLCJ4IiwiaXNPYmplY3QiLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByaW50IiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hpZnRJdGVyYXRvciIsImlucHV0IiwiZG9uZSIsIm5leHQiLCJ1bmRlZmluZWQiLCJ0b0ZhaWx1cmUiLCJyZXN1bHQiLCJjb250ZXh0Iiwic3RydWN0IiwiYnJhbmNoIiwidHlwZSIsInJlZmluZW1lbnQiLCJrZXkiLCJ0b0ZhaWx1cmVzIiwiciIsInJ1biIsIm9wdGlvbnMiLCJjb2VyY2UiLCJtYXNrIiwiY3R4IiwiY29lcmNlciIsInNjaGVtYSIsIkFycmF5IiwiaXNBcnJheSIsInZhbGlkIiwidmFsaWRhdG9yIiwiayIsInYiLCJzIiwiZW50cmllcyIsInRzIiwidCIsIk1hcCIsInNldCIsIlNldCIsImFkZCIsInJlZmluZXIiLCJTdHJ1Y3QiLCJwcm9wcyIsImFzc2VydCIsImNyZWF0ZSIsImlzIiwidmFsaWRhdGUiLCJ0dXBsZXMiLCJ0dXBsZSIsImVycm9yIiwiU3RydWN0cyIsInNjaGVtYXMiLCJtYXAiLCJvYmplY3QiLCJkZWZpbmUiLCJkZXByZWNhdGVkIiwibG9nIiwiZHluYW1pYyIsImZuIiwibGF6eSIsIl9zdHJ1Y3QiLCJfc3RydWN0MiIsIl9zdHJ1Y3QzIiwib21pdCIsImtleXMiLCJzdWJzY2hlbWEiLCJwYXJ0aWFsIiwib3B0aW9uYWwiLCJwaWNrIiwiY29uc29sZSIsIndhcm4iLCJhbnkiLCJhcnJheSIsIkVsZW1lbnQiLCJpIiwic2xpY2UiLCJib29sZWFuIiwiZGF0ZSIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJlbnVtcyIsInZhbHVlcyIsImRlc2NyaXB0aW9uIiwiaW5jbHVkZXMiLCJmdW5jIiwiaW5zdGFuY2UiLCJDbGFzcyIsImludGVnZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpbnRlcnNlY3Rpb24iLCJTIiwibGl0ZXJhbCIsImNvbnN0YW50IiwiS2V5IiwiVmFsdWUiLCJuZXZlciIsIm51bGxhYmxlIiwibnVtYmVyIiwia25vd25zIiwiTmV2ZXIiLCJ1bmtub3ducyIsImRlbGV0ZSIsInJlY29yZCIsInJlZ2V4cCIsIlJlZ0V4cCIsInN0cmluZyIsIkVsZW1lbnRzIiwiTWF0aCIsIm1heCIsInVuaW9uIiwiZmlyc3QiLCJwdXNoIiwidW5rbm93biIsImNvbmRpdGlvbiIsImRlZmF1bHRlZCIsImZhbGxiYWNrIiwiZiIsInN0cmljdCIsInJldCIsImNoYW5nZWQiLCJ0cmltbWVkIiwidHJpbSIsImVtcHR5IiwiZXhwZWN0ZWQiLCJyZWZpbmUiLCJzaXplIiwidGhyZXNob2xkIiwiZXhjbHVzaXZlIiwibWluIiwicGF0dGVybiIsInRlc3QiLCJzb3VyY2UiLCJvZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/superstruct/lib/index.es.js\n");

/***/ })

};
;